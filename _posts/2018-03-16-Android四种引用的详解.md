---
layout:     post
title:      android四种引用的详解
subtitle:   android四种引用的详解
date:       2018-03-16
author:     pxf
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - Android
---
android四种引用的详解
===

## 简述：

在android开发中，开发到一定程度的之后，就会开始关注关于APP的各种性能优化，其中很重要的一个点，就是关于四种引用的合理引用，另外在android的各种面试中，也会经常被问到关于四种引用的各种问题。

## 哪四种引用

四种引用分别为： 
* 1\. 强引用（StrongRefernce） 
* 2\. 软引用（SoftReference） 
* 3\. 弱引用（WeakReference） 
* 4\. 虚引用（PhantomReference）

## 引用的概念理解

### 为了后面能够更好的阐述四种引用，我们先讲述一下关于什么是引用

在java中，没用指针，对象的操作全部凭借引用来与之产生关联，通过操作相关联的引用，来达到操作所需对象的目的，所以，可以言简意赅的理解为，引用，是用来操作对象的。 
例如：

```
User u1 = new User();

```

在当前的这句语句中，我们创建了一个对象User，然后这个对象会被分配到堆内存中的一个位置进行存储;而局部变量 u1被存储在栈内存中。

这时，我们通过一个引用名 为u1的引用对这个User进行相关联，通过u1我们就可以操作到这个User对象。

假如上面的那行代码是在一个方法体内执行的，而这时我们再写一行这样的代码

```
User u2 = u1;
```

那么这时，u1持有可以操作的对象User，同时也会被u2持有。u1、u2同时关联同一个对象。 
而在内存中，是这样的 
![image](http://img.blog.csdn.net/20170908121828537?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyODA2ODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**，一个对象，是可以被多个引用持有的，而另外值得注意的一点是，并且可以是不同的引用。** 这一段话为什么要字体加粗呢，因为这对于后面各种引用回收的理解，有着重要作用。

## 强引用（StrongReference）

四种引用中，强引用是我们使用的最多的一种引用对象，对强应用的使用，在编码过程中也是无处不在，例如创建一个成员变量，new 出一个对象等等……；

强引用可以直接访问目标对象，强引用所关联的对象，在任何时候都不会被内存回收，JVM宁肯抛出OOM异常，也不会对其进行回收，所以，在通常的内存泄漏中，大多都有强引用的身影。

## 软引用（SoftReference）

软引用是除了硬引用之外最强的一种引用，软引用和硬引用的不同点在于，软引用是可被回收的；

其回收机制是：当内存充足的时候，在GC时,不会去回收当前的软引用，当内存临近阈值或不足的时候，在GC时，发现**某一对象的引用只具有软引用**当前软引用就会被回收。

**当一对象除了具有软引用还具有硬引用，GC时，会被回收吗？答案是肯定不会，只会回收只具有软引用的对象**

### 另外值得说的一点是，以前缓存图片都会选择使用软引用，虽然它当内存不足时才回收的特点很符合作为缓存，但缺点也很明显

*  关于这部分缓存被回收时，并没有一套机制去进行衡量，例如先回收离上次使用间隔时长最长的，而是随GC随机回收；

*  当手机内存使用比较高的时候，那么在理论上来说，GC的频率也就会更高，需要不断的释放掉相应的内存来腾出空间，而在这个时候，也将意味着软引用，也将会被高频率清理，在这个过程中起到缓存的实质性质效果很低，软应用刚创建好不一会就被清理，不一会就被清理，站在性能优化的角度来说，效果并不明显，并且在被回收后还是需要不断重新创建，这也是消耗性能的。

**所以关于图片的缓存，谷歌后来推出了LruCache，底层是LinkHashMap解决了上述的第一点问题，而可以设定存储大小则是很好的解决了第二点问题。**

## 弱引用（WeakReference）

弱引用是比软引用和硬引用更弱的一种引用，在GC时，不论内存是否充足，发现**某一对象的引用只具有弱引用**当前弱引用就会被回收。

**当一对象除了具有弱引用还具有硬引用，GC时，会被回收吗？答案是肯定不会，只会回收只具有弱引用的对象**

在很多时候，弱引用会被组合起来一起使用，例如其中一个使用场景：Handler的匿名内部类的实现中，可能会导致内存泄漏，使用静态内部类解决持有外部引用问题，将需要的外部引用使用弱引用，而像在这部分的实际运用场景下，弱引用的使用是更符合规范，但不一定有效呢，比如弱引用持有的对象，这个对象还有硬引用，在GC时，这不符合回收规则，这个对象就不会被回收。

## 虚引用(PhantomReference)

虚引用不能保证其保存对象生命周期，其保存对象若只有虚引用，则其有效期完全随机于GC的回收，在任何一个不确定的时间内，都可能会被回收；而虚引用与其他几者的引用不同在于，在使用PhantomReference，必须要和Reference联合使用。

## 总结与注意事项

前面对各种引用进行了详细的解说，然后关于这几种引用，在使用过程中，有一个细节还是非常值得注意的，软引用，弱引用，虚引用，在创建引用对象的时候，除了传入引用对象，通常还有一个构造函数，多了一个ReferenceQueue

```
        ReferenceQueue queue = new ReferenceQueue();
        WeakReference weakReference = new WeakReference(this,queue);
        SoftReference softReference = new SoftReference(this,queue);
        PhantomReference phantomReference = new PhantomReference(this,queue);
```

**那么这个ReferenceQueue有什么用呢？**

**引用对象本身，也是一个强引用，其除了具有保存一个对象本身特有的引用属性之外，引用对象本身也具有java对象的一般性，那么在其本身保存的对象被回收之后，引用对象本身也就没有了实用性质，需要一个适当的清理机制，来清理这些对象，避免大量这些引用对象而带来的内存泄漏；这时候，就可以用到ReferenceQueue。**

**当引用（SoftReference/WeakReference/PhantomReference）中保存的的对象，被GC回收时，引用本身的这个对象会被加入到ReferenceQueue中，那么，也就是说，ReferenceQueue中保存的对象是Reference，并且是失去了其保存的对象的Reference。这个时候我们可以通过调用ReferenceQueue中提供的poll()这个API来获取队列中的对象，当队列中不存在对象的时候，返回的会是null，当存在或存在多个的时候，都是返回最前面的一个Reference对象，这个时候我们就需要将这个对象进行清除，让相应的内存可以被释放掉。**

```
Reference ref = null;
        while ((ref =  queue.poll()) != null) {
            // 清除ref
        }
```

