模块化与组件化开发
===

**模块化，组件化是一种处理复杂系统分解为更好的可管理模块的方式。**

# 模块化
模块化就是将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容。模块我们相对熟悉,比如登录功能可以是一个模块,搜索功能可以是一个模块。

# 组件化
组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，已较少耦合。

# 模块化vs组件化
模块化和组件化本质思想是一样的,都是”大化小”,两者的目的都是为了重用和解耦,只是叫法不一样.如果非要说区别,那么可以认为模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦。

# 模块化与组件化优缺点

组件化是指以重用化为目的，将一个系统拆分为一个个单独的组件

## 优点
*   **1.模块间解耦，复用，避免重复造轮子，节省开发维护成本**
对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个都是独立的模块，它们之间是没有依赖关系。每个模块负责的功能不同，业务逻辑不同，模块间业务解耦。模块功能比较单一，可在多个项目中使用

*   **2.可单独编译某个模块，降低项目复杂性，提升开发效率**
每个模块实际上也是一个完整的项目，可以进行单独编译，调试

*   **3.可以多团队并行开发，测试 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性**
 每个团队负责不同的模块，提升开发，测试效率

## 缺点
对开发人员和团队管理者提出了更高水平的要求，相对传统方式,在项目的管理和组织上难度加大,要求开发人员对业务有更深层次上的理解。

# 组件化与模块化

组件化与模块化业务分层：由下到上

组件与模块以jar的形式呈现,或以aar的形式呈现。主工程通过依赖的方式使用组件所提供的功能，其本质上都是Library,他们不能脱离主工程而单独的运行。

## 基础组件层：

* 底层使用的库

* 封装的基类，例如：BaseApplication，BaseActivity，BaseFragment，BaseAdapter等。

* 一些工具库（libs），比如获取App设备信息（AppInfoUtil），日志工具类（LogUtil），包相关的工具（PackageUtil），Toast工具类（ToastUtils），资源工具类（ResourceUtil）等。

* 缓存库

* hybrid混合开发库

* 网络库（RetrofitUtil）

* UI库（UIKit）

## 业务组件层：（与业务相关）

* 分享库

* 相册库

* 二维码扫描

* 直播库

## 业务模块层：（按照业务划分模块）
* 登录模块

* 搜索模块

* 支付模块

* 金融交易模块

* 社区模块

[谈谈我的理解-组件化/模块化](https://www.jianshu.com/p/79e4df63f31f)

[Android模块解耦之组件化实现之踩坑](https://www.jianshu.com/p/c611c2c9a309)

[Android组件化方案](https://link.jianshu.com/?t=http://blog.csdn.net/guiying712/article/details/55213884)这篇文章讲的最好，还设计大量 gradle 配置的思考

## 工程隔离
1.  每个工程都可以独立编译、独立打包；
2.  每个工程内部的修改，不会影响其他工程；
3.  业务库工程可以快速拆分出来，集成到其他App中。

## 组件
主 app 就是我们常说的壳工程依赖这些 module，library 由需求的 module 依赖，但是要考虑library 版本的问题，随着业务和功能的扩展

组件就是通过library打包成的arr来给壳工程引用的，arr 和 jar 在编译时是不会再编译的，只会检查版本，保留一个最新的版本，既提高了 app 的编译速度，页提供一种资源冲突解决方式。

## 组件间通信
router 是我们统一制定的模块间通讯协议，router 中我们主要是处理一下几个问题：

*   模块之间页面跳转
*   模块之间数据传递
*   模块初始化处理

使用的思路都是把 router 作为一个组件，所有的业务 module 都依赖这个 router 组件，当然壳app 也是，然后我们把需要的模块间页面跳转，数据传递，初始化都注册到 router 中，这里面就体现到我们定义的统一，通用的模块通讯协议的重要性了，router 维护多个集合保存这里关系，然后我们通过router 就可以实现模块间的通讯了。

router 的封装还是挺麻烦的，要写好了不容易，现在用的比较多的有：

*   阿里的 ARouter
*   最早出现的 ActivityRouter
*   spiny同学的[router](https://link.jianshu.com?t=http://blog.spinytech.com/2016/12/28/android_modularization/)这是我的最爱，目前不维护了，思路很棒，并且考虑到了进程化的问题，可惜没有使用 APT 注解技术
*   练手的 [router](https://link.jianshu.com?t=https://github.com/chenenyu/Router)

module 间的通讯其实可以分成3种：

*   页面调起
*   某种事件的通知
*   直接调用某些模块的业务方法

我们一定要熟悉gradle的使用，在组件化中我们会大量的使用 gradle 提供各种资源加载的配置和环境配置

组件化最核心的目的就是代码的高可复用和高可维护和高可扩展性能，其他的优点都是属于连带性质的，我们要先把握住核心点学习，其他的都不是主要，有时间再看

### 组件化初衷

*   APP版本不断的迭代，新功能的不断增加，业务也会变的越来越复杂，维护成本高。

*   业务耦合度高，代码越来越臃肿，团队内部多人协作开发困难。

*   Android项目在编译代码的时候电脑会非常卡，又因为单一工程下代码耦合严重，每修改一处代码后都要重新编译打包测试，导致非常耗时。

*   方便单元测试，改动单独一个业务模块，不需要着重于关注其他模块被影响。

### 什么是组件化

组件化就是将一个app分成多个Module，如下图，每个Module都是一个组件(也可以是一个基础库供组件依赖)，开发的过程中我们可以单独调试部分组件，组件间不需要互相依赖，但可以相互调用，最终发布的时候所有组件以lib的形式被主app工程依赖并打包成一个apk。

### 组件化优势

*   组件化就是将通用模块独立出来，统一管理，以提高复用，将页面拆分为粒度更小的组件，组件内部除了包含UI实现，还包含数据层和逻辑层。

*   每个工程都可以独立编译、加快编译速度，独立打包。

*   每个工程内部的修改，不会影响其他工程。

*   业务库工程可以快速拆分出来，集成到其他App中。

*   迭代频繁的业务模块采用组件方式，业务线研发可以互不干扰、提升协作效率，并控制产品质量，加强稳定性。

*   并行开发，团队成员只关注自己的开发的小模块，降低耦合性，后期维护方便等。

### 指导思想

*   组件拆分：将一个project划分成业务组件、基础组件、路由组件。其中业务组件是相互隔离的，可以单独调试，基础组件提供业务组件所公用的功能，路由组件为业务组件之间通信提供支持。

*   组件隔离：业务组件之间的隔离，可以单独调试。

*   核心法则：编译期隔离，运行期按需依赖。

### 依赖关系

![](https://mmbiz.qpic.cn/mmbiz_jpg/nk8ic4xzfuQ9caH7VeQLsuj5FyISU8rr4n4PI9N93nQdgGicRia0VVIsQaj1icO1ZLfegk188jEqaAGlaDlR3OWLWw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1)

### 组件化需要考虑的问题

####   **模式切换**：

如何使得APP在单独调试跟整体调试自由切换

组件化后的每一个业务的module都可以是一个单独的APP`（isModuleRun=false）`， release 包的时候各个业务module作为lib依赖，这里完全由一个变量控制，在根项目 `gradle.properties`里面的 `isModuleRun=true`。

isModuleRun状态不同，加载application和AndroidManifest都不一样，以此来区分是独立的APK还是lib，

####   **资源冲突**：

当我们创建了多个Module的时候，如何解决相同资源文件名合并的冲突

业务Module和BaseModule资源文件名称重复会产生冲突，解决方案在
每个 module 都有 app_name，为了不让资源名重名，在每个组件的 build.gradle 中增加 `resourcePrefix “xxx_`强行检查资源名称前缀。
固定每个组件的资源前缀。但是 resourcePrefix 这个值只能限定 xml 里面的资源，并不能限定图片资源。
个人认为约定大于配置，团队内协定好规范，可以避免冲突。


####   **依赖关系**：

多个Module之间如何引用一些共同的library以及工具类


####   **组件通信**：

组件化之后，Module之间是相互隔离的，如何进行UI跳转以及方法调用

选择阿里的ARouter，
各业务Module之间不需要任何依赖可以通过路由跳转，完美解决业务之间耦合

####   **入口参数**：

我们知道组件之间是有联系的，所以在单独调试的时候如何拿到其它的Module传递过来的参数

当组件单独运行的时候，每个Module自成一个APK，那么就意味着会有多个Application，很显然我们不愿意重复写这么多代码，所以我们只需要定义一个BaseApplication即可，其它的Application直接继承此BaseApplication就OK了，BaseApplication里面还可定义公用的参数
