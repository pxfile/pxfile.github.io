面试总结12
===

如何开启多进程?应用是否可以开启N个进程？

Activity的启动模式、任务栈以及使用场景？

Volley能否进行数据量很大的请求，比如说加载100M的图片？

手写快速排序

Volley的优缺点

final修饰一个对象，能否调用对象修改属性的方法

子线程中如何使用Handler

如何进行单元测试,如何保证APP稳定。

TabLayout如何设置指示器的宽度包裹内容？

公差为1的等差数列求和，如何优化

自己的优势在哪里

注解如何获取，反射为何耗性能？

Java的GC机制，分代回收策略

Binder机制：ServiceManager什么时候注册的？

int,long的取值范围以及BigDecimal，数值越界了如何处理？

ConcurrentHashMap的原理，分的段数是多少？

APP是如何适配的？

Android中如何查看一个对象的回收情况？

最大一次线上Bug处理措施

APK的大小如何压缩

APP的崩溃率，多渠道包

自己做过的APP用户量

能否接受加班

MVP如何管理Presenter的生命周期，何时取消网络请求

用过的框架及原理

天猫的Tangram布局，vLayout原理

APP的启动流程

回形打印二维数组

Java为何引入泛型，泛型边界

常见的Java数据结构

ArrayMap跟SparseArray在HashMap上面的改进

Java的四种引用及使用场景

Webview性能优化

Binder机制

ClassLoader的理解

Arouter的原理

组件化原理，组件化中路由的实现

热修复跟插件化的原理

线程池的几个参数的理解，四种线程池的使用场景

常用的设计模式，手写DCL单例模式

进程间为什么不能直接进行通信

应用跟系统之间通信什么时候用Socket什么时候用Binder

GitHub上面的开源项目

一个线程能否创建多个Handler，Handler跟Looper之间的对应关系

ArrayList跟HashMap是够线程安全，如何保证线程安全

Volley返回数据量比较大的请求时怎么办

ListView跟RecyclerView刷新数据原理，使用到的设计模式

适配如何做，有没有适配过全面屏

Fragment跟Activity的通信方式，你知道几种？

内存泄露的种类

ActivityA启动ActivityB时生命周期的变化

AMS是如何管理Activity的

JVM中的GC回收机制

常见的跨进程通信方式，AIDL的实现原理

APP以及Activity的启动流程

Hook以及插桩技术

StringBuffer跟StringBuilder之间的区别

并发相关，各种锁

View的绘制流程，事件分发

Hashmap,Arraymap，SparseArray

四种引用

MVP跟MVC的区别

LV跟RV之间的区别

Service相关，startService以及bindService

Fragment不同于Activity的生命周期

生产者消费者问题：一对多，多对多情况

常见的设计模式，并选择一种描述一下

Scroller的使用

Gradle生命周期

Java&Android关于Classloader源码解析

Python的class文件

DCL中Volatile的作用，如何防止反射实例化单例对象

抽象类能否实例化，理论依据是什么？

如何通过Gradle配置差异较大(20%差异)的多渠道包

class文件如何转化成dex

Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？

JVM相关,DVM以及ART是如何进行优化的，具体步骤

长连接常见的库，短链接

静态同步锁与普通同步锁的区别

直接在Activity中创建一个thread跟在service中创建一个thread之间恩区别

View的生命周期

View的绘制流程跟事件分发

Activity跟Window之间的关系

对C跟JNI是否熟悉

热修复原理，插件化是如何进行加载插件的

Java中的锁，各种同步方式之间的区别

ANR在四大组件中的时间，场景

OOM，如何避免

内存泄露原理，如何避免

MVC跟MVP之间的区别

ListView针对多种item的缓存是如何实现的

Android绘制二维跟三维的View的区别

是否了解硬件加速

ListView是如何实现对不同type的item的管理的

Android中IPC方式，各种方式优缺点，为什么选择用Binder

主流的热修复框架流派，原理，是否研究过classloader源码

Android为什么要设计两种classloader，为什么不用一种，通过type来区分

Bundle传递数据为什么需要序列化

手写一个快排，分析原理

广播传输的数据是否有限制，是多少，为什么要限制？

Activity启动时生命周期是如何回调的？

MVP.MVC.MVVM之间对比分析

组件化通讯:有几种通信方式，Arouter原理

插件化加载流程，原理

关于反射混淆，耗性能的解决方式

天猫七巧板布局原理

热修复流派，原理

RecyclerView的itemdecoration如何处理点击事件

单例模式如何修改数据

android事件传递，非常细

多线程

一面面试官可能比较忙，没有问太多的问题，主要聊了聊我GitHub上面的开源项目，当时这个聊了很久，然后说了他们项目中也采用了ItemDecoration的列表联动，然后就问了我如何处理ItemDecoration的多个点击，最后聊到了事件分发机制，主要是在ListView里面嵌套一个Button以及在ListView里面嵌套一个ScrollerView让我说一下事件在dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent中的传递过程，面试官先让我说，我只是说了大体流程，然后面试官又给详细地分析了一遍，分析地非常详细，确实让我受益匪浅，自己对事件分发的理解又更加进了一步。

JVM内存分布，Classloader

静态代理跟动态代理

线程的生命周期

是否用过DataBinding

是否接触过JNI

对热修复跟插件化了解多少

对RN了解多少

二分查找

说下多态

编译期注解跟运行时注解

线程跟进程间通信

Android中的IPC

java中的传递

equals跟==

Picasso的存储

项目中的难点

项目中用到了哪些第三方

MVC,MVVM,Clean架构

抽象类跟接口的区别，接口的默认修饰符

Canvas.save()跟Canvas.restore()的调用时机

程序A能否接收到程序B的广播？接入微信支付的时候，微信是如何跟当前程序进行通信？

对Java.nio了解多少

ConcurrentHashMap是如何实现分段锁？

现在需要遍历SD卡下所有的文件打印出后缀名为.txt文件名称，如何提高时间效率？

为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？

Android4.0～8.0之间大的变化，如何处理？

说一下Measurespec这个类

ViewHolder有什么用？

Gradle的Flavor能否配置sourceset？

线程池核心线程数一般定义多少，为什么？

Intentservice有什么用

弱引用什么时候被回收

Android中提供了哪些类来帮忙处理线程

http的状态码，常见的请求头，http缓存协议https如何加密

多进程的优缺点，多线程的优缺点

热修复如何修复资源文件？

有没有遇到64k问题，为什么，如何解决？

httpUrlconnection跟httpClient有什么区别

两个非基本数据类型数组： array1=[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,×11] array2=[x6,x3,x10,x5] 计算结果：[x6,x7,x8,x9,x1,x2,x3,x4,x10,x11,x5],写出你的算法

类的初始化过程

点击事件穿透原则

线程池使用的是哪一种，使用原则

LeakedCanary原理

LinerLayout跟RelativeLayout的绘制原理

Android新版本的一些新特性6.0,7.0,8.0

类的初始化顺序依次是（静态变量、静态代码块）>（变量、代码块）>构造方法

看了看项目提了问题如何进行优化

如何实现马蜂窝中的一个动画效果

软键盘顶起布局

组件化通信方案

聊聊RecyclerView，动画，缓存，数据绑定底层是如何实现的。

聊了聊我的开源项目实现原理

View在屏幕中的移动底层是如何实现的

Binder跟Socket之间的区别，什么时候用哪一个，Binder的底层实现

Activity,Window跟View之间的关系

setContentView都干了啥

Activity的启动模式

MVC跟MVP之间的区别

算法：将一个有序数组去重得到一个新数组(空间复杂度为O(N))

LruCache底层实现

Hashmap的hash算法

Bitmap在decode的时候申请的内存如何复用，释放时机

注解如何实现一个findViewById

Android是如何学习的

sycronized关键字的类锁对象锁，如何保证线程安全？

重入锁跟sycronized关键字之间的区别

除了notify还有什么别的方式可以唤醒线程

说说你对Context的理解

Listview的adapter是什么adapter，如何复用。

RV是如何布局的

算法：如何从1T的无序数组(长度为n)里面找出前k大的数据，复杂度要求为O(logN)

由A启动BActivity，A为栈内复用模式，B为标准模式，然后再次启动A或者杀死B，说说A，B的生命周期变化，为什么

1.APP启动流程 2.Webview内存泄露 3.组件间通信，如何传递对象 4.Arouter原理 5.如何取消一个网络请求 6.两个activity之间来回切换的生命周期变化 7.进程间如何通信，Binder机制 8.内存泄露及优化 9.自定义view以及事件冲突 10.线程池参数及定义，多线程是否一定会高效 11.电量优化
Webview的性能优化

Sycronized原理

ReentrantLock原理

静态内部类为什么能保证单例，JVM是如何实现的

ART跟DVM做了哪些优化

View是如何绘制到屏幕上的

写一个快排，有时间限制

二面面试官问地特别深，一上来就是各种原理 问了很多原理的原理，比如说Sycronized原理，View如何绘制到屏幕上去，这些对于我来说确实比较难，然后还问到了AQS, CAS的底层实现，答地一般般，我基本上对于JMM的了解就是类锁对象锁，指令重排序等

**三面：**

GitHub上的开源项目是如何实现的

未来的职业规划

遇到问题如何解决

为什么没有自己搭建SS 三面是猎豹移动的产品总监，没有问技术上的问题，基本上如实回答就行了，没有那么多的套路，真诚即可。

**一面：**

深拷贝浅拷贝

输出一个集合{A,B,C,D}的全部子集

自定义View及注意事项

如何自动化部署打包发包流程

JNI是否了解过

内存回收

classloader

对热修复以及插件化了解多少

微信支付宝支付调用时上层是如何封装AIDL的

如何给一个app瘦身

基本上在之前的面试都有涉及到，依然是问我会的东西，一点点深入，第9道面试题我记得在掌阅面试的时候那个面试官说微信用地是广播，但是摩拜的面试官说微信用地是start ActivityForResult，这个我决定以后自己去深入研究下，看看他们到底是如何实现的，别的问题都是比较常见的。

**二面：**

如何实现一个推送，极光推送原理

说说Http协议，以及Tcp/Udp

常见的设计模式，如何实现一个观察者模式，如果需要有序通知观察者，该如何操作

实现一个图片加载框架应该考虑哪些

线程池有哪些参数，应该如何设计

性能优化是如何做的

Java为什么要推出HashMap，它是如何解决hash冲突的

JVM内存分配，编码时如何注意内存泄露

Binder机制原理

摩拜问地都是很常见的问题，我能感觉到面试官在问我问题的时候并不在乎我对这个问题掌握地有多好，而是更加关注我对待某个知识点的态度，更多地赋予面试题一个场景，而不是空谈理论，是我比较喜欢的面试官。

**三面：**

为什么重复造轮子，自己去设计一些框架的原因

如何保证线上项目的稳定性

自己之前做的项目的规模

聊了聊他们目前在做的项目

三面面试官跟我聊了聊一些新技术，还有就是我自己为什么要重复造轮子，我说为了保证项目的稳定性同时能够更好地去定位问题，然后聊了聊他们目前在做的项目，整体感觉特别好。

# 如何开启多进程?应用能不能一上来能不能开多个进程保活

在清单文件中四大组件的Android：process开启额外的进程。
不能，因为多进程首先会有多个Application，数据会被初始化多次，其次进程间通信比较麻烦，还有一个就是每个进程有单独的虚拟机，多个进程就会比较占内存。

# Volley能否进行数据量很大的请求，比如说加载100M的图片？

不行，因为Volley是在内存中进行操作，ImageRequest去加载大图片的时候，也是在内存中读取的，这个时候就会有OOM问题

# Volley 优缺点

### Volley到底有哪些特点呢？

*   自动调度网络请求
*   多个并发的网络连接
*   通过使用标准的HTTP缓存机制保持磁盘和内存响应的一致
*   支持请求优先级
*   支持取消请求的强大API，可以取消单个请求或多个
*   易于定制
*   健壮性：便于正确的更新UI和获取数据
*   包含调试和追踪工具

### Volley优点

1.  可以取消请求
2.  容易扩展，面向接口编程
3.  网络请求线程NetworkDispatcher默认开启了4个，可以优化，通过手机CPU数量
4.  提供简便的图片加载工具;

### Volley缺点

1.它只适合数据量小,通信频繁的网络操作,如果是数据量大的,像音频,视频等的传输,还是不要使用Volley为好.

2.  在BasicNetwork中判断了statusCode(statusCode < 200 || statusCode > 299)，如何符合条件直接抛出IOException()，不够合理

3.  导致401等其他状态抛出IOException 
    解决方案 : 
    [http://blog.csdn.net/kufeiyun/article/details/44646145](http://blog.csdn.net/kufeiyun/article/details/44646145) 
    [http://stackoverflow.com/questions/30476584/android-volley-strange-error-with-http-code-401-java-io-ioexception-no-authe](http://stackoverflow.com/questions/30476584/android-volley-strange-error-with-http-code-401-java-io-ioexception-no-authe)
3.  图片加载性能一般

# final修饰一个对象，能否调用对象修改属性的方法

用final修饰的基本类型变量表示该变量的值一旦被赋予，就不再允许被改变；

而用final修饰的引用类型变量表示该变量所指向的对象不可变，但是对象的具体属性值可以被修改。也就是说，一旦将一个final变量指向一个变量，则不能再将其指向另一个变量，即引用不可变，但是引用的对象属性可变。

用final修饰的变量在使用前必须被初始化，初始化可以是在定义时同时进行，也可以是在构造函数中进行，但二者只能任选其一，毕竟只能被赋值一次嘛~~

### final参数

可以将final修饰的参数看做一个只读参数，只可以读取该参数的值，但不允许对该参数进行修改。_这一特性主要用于向匿名内部类传递数据。_

### final 方法

final方法不能被重写，使用final方法主要出于两方面考虑：

*   设计：将方法锁定，以防任何继承类覆盖修改该方法；
*   效率：这主要出现在Java的早期实现中，若将一个方法指明为final的，那么就是同意编译器将针对该方法的所有调用均转化为内嵌调用，当编译器发现一个final方法调用时，就会根据 自己的判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压栈，跳至方法代码处并执行，然后跳回并清理栈中参数，处理返回值）并以方法体中的实际代码的副本来替代方法调用，这将消除方法调用的开销。在Java SE5以后，JVM可以自动对这类情况进行优化，所以基于效率而使用final方法的做法不再实用。

### final 类

final类不允许被继承，当一个类不希望被修改或不希望被继承时才会被设计为final的。**final类中的所有方法都隐式为final的**，因为不能对这些方法进行覆盖和修改。
final类中的非final域变量可以被修改

```
final class FinalClass{
    int a = 8;
}
public class FinalTest {
    public static void main(String[] args) {
        FinalClass fc = new FinalClass();
        OutUtil.print(++fc.a);
    }
}
//Output: 9

```

### 注：

*   一个被static final修饰的域只占据一段不能改变的存储空间
*   final变量并不一定在编译期就可以获知他们的值，比如

```
static Random rand = new Random(47);
final int i = rand.next(20);    // i 的值需要到运行时才可知

```
# 如何保证APP稳定

Android 应用的稳定性定义很宽泛，影响稳定性的原因很多，比如内存使用不合理、代码异常场景考虑不周全、代码逻辑不合理等，都会对应用的稳定性造成影响。其中最常见的两个场景是：Crash 和 ANR，这两个错误将会使得程序无法使用，比较常用的解决方式如下：

### 提高代码质量。比如开发期间的代码审核，看些代码设计逻辑，业务合理性等。

### 代码静态扫描工具。常见工具有Android Lint、Findbugs、Checkstyle、PMD等等。

### Crash监控。把一些崩溃的信息，异常信息及时地记录下来，以便后续分析解决。

### Crash上传机制。在Crash后，尽量先保存日志到本地，然后等下一次网络正常时再上传日志信息。

# TabLayout如何设置指示器的宽度包裹内容？

### 方案一：反射，使用麻烦，有时还不好用。 

这个的思路来自stackoverflow，大致过程是 由TL拿到其唯一的子类，即SlidingTabStrip，然后遍历再拿到其各子View，然后为每个子View设置Margin，这就相当于给每个tab设置margin，那么指示器的宽度自然也就跟着改变了。

### 方案二：自定制指示器显示

属于自定制指示器显示，相对比较灵活，能解决方案1的tab等宽问题，但是其缺点是不能保留指示器的动画。具体过程： 
TL中tab可以设置自定义view，方法是setCustomView(@Nullable View view) ，也就是说，完全可以不用TL中那套，直接自定义布局即可。

# 注解如何获取，反射为何耗性能？


注解是通过反射获取的，Android中也能通过apt工具在编译时期获取

java反射之所以慢，最主要的就是就是编译器没法对反射相关的代码做优化。稍微了解像gcc这类编译器的人都知道，他们是可以把你又臭又长的代码优化的多么好，java的编译器也是类似

# Binder机制：ServiceManager什么时候注册的

系统服务一般都是通过ServiceManager的addService进行注册的，这些服务一般都是需要拥有特定的权限才能注册到ServiceManager

# int,long的取值范围以及BigDecimal，数值越界了如何处理？


**越界了没法处理，从能类更大类型的，Short，byte越界需要强转，int，long类型转换属于向上转型是自动进行的。**

越界时编译器会报错，因为我们没法把int类型的值直接转换为byte类型，必须进行强制转换：byte b = （byte）（a + 1）；而int，long类型转换属于向上转型是自动进行的，所以编译器不会报错。

在Java中一共有8种基本数据类型，其中有4种整型，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型和1种用于表示真值的boolean类型。（一个字节等于8个bit）

1.整型

| 类型 | 存储需求 | bit数 | 取值范围 | 备注 |
| --- | --- | --- | --- | --- |
| byte | 1字节 | 1*8 | -128～127 |   |
| short | 2字节 | 2*8 | -32768～32767 |   |
| int | 4字节 | 4*8 | -2^31 ~ 2^31-1 |   |
| long | 8字节 | 8*8 | -2^63 ~ 2^63-1 |   |

2.浮点型

| 类型 | 存储需求 | bit数 | 取值范围 | 备注 |
| --- | --- | --- | --- | --- |
| float | 4字节 | 4*8 | 2^-149 ~ (2-2^-23)·2^127 | float类型的数值有一个后缀F(例如：3.14F) |
| double | 8字节 | 8*8 | 2^-1074 ~ (2-2^-52)·2^1023 | 没有后缀F的浮点数值(如3.14)默认为double类型， Double 有静态变量 `MIN_VALUE` 和 `MAX_VALUE`。 |

3.char类型

| 类型 | 存储需求 | bit数 | 取值范围 | 备注 |
| --- | --- | --- | --- | --- |
| char | 2字节 | 2*8 | 0 ~ 65,535 |   |

4.boolean类型

| 类型 | 存储需求 | bit数 | 取值范围 | 备注 |
| --- | --- | --- | --- | --- |
| boolean | 1字节 | 1*8 | false、true |   |

补充：Java有一个能够表示任意精度的算术包，通常称为“大数值”(big number)。虽然被称为大数值，但它并不是一种Java类型，而是一个Java对象。 如果基本的整数和浮点数精度不能够满足需求，那么可以使用 `java.math` 包中的两个很有用的类：`BigInteger` 和 `BigDecimal` (Android SDK中也包含了`java.math`包以及这两个类)这两个类可以处理包含任意长度数字序列的数值。
`BigInteger `类实现了任意精度的整数运算，
`BigDecimal` 实现了任意精度的浮点数运算。

**BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值**。

BigInteger 和 BigDecimal 都是不可变 immutable ，类似于 String， 在使用

```
BigInteger sum = new BigInteger.valueOf(0);
sum.add(BigInteger.valueOf(10));    // wrong way, sum is still 0
sum = sum.add(BigInteger.valueOf(10));   // right way, add() return a BigInteger Object.
```

任何整型类型的最大值+1，结果返回该类型的最小值。

# ConcurrentHashMap的原理，分的段数是多少？

concurrencyLevel=16

# Android中如何查看一个对象的回收情况

对于`软引用`和`弱引用`，我们希望当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。ReferenceQueue即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。

# 最大一次线上Bug处理措施

## 1.  线上BUG来源

**用户反馈**

用户反馈由运营或者客服或PD童鞋进行收集，对集中反应比较多的问题反馈到项目组及相关童鞋，对体验不好的地方进行产品改进。

**回归测试**

每周服务端预发和上线以后，在客户端进行回归测试工作，现在是由专门的童鞋进行回归，以后的方向是自动化回归。

**适配测试**

对于厂商反馈的适配BUG，由相关测试童鞋进行验证，不管是通性BUG还是适配BUG都属线上BUG,测试童鞋应及时反馈给开发童鞋，优先级最高。

当然线上BUG来源有很多，项目组童鞋在日常使用的过程当中，或是自动化回归的测试当中也会发现一些问题，都及时反馈给相关童鞋就好了，避免用户反馈的时候才去跟进，这样有利于减少线上BUG的在线时间。

## 2.  线上BUG反馈给

线上BUG应该反馈给PM、QA、TL以及项目级成员。

PM作为Ower，排出优先级，可指定QA进行定位，督导开发解决，直至问题完全fixed。由于线上BUG分为两类：客户端的BUG和服务端的BUG，如果是服务端的BUG，客户端PM应该能够举证并且通过严重级别督促服务端开发尽快解决问题。

## 3.  线上BUG定位

测试童鞋通过以下方法快速定位：

1、 为了节省定位时间，进行有针对性的验证，尽可能多的了解BUG产生的环境（比如：使用的网络、机型）

及操作步骤

提醒：开发童鞋应该对软件发生错误的提示进一步优化，做到更加明确，这样用户反馈以后我们就可以快速定位了。

2、 根据反馈的功能点进行针对性的回归接口测试用例

3、 用Debug包进行测试，查看抓取的log，观察请求的API是否正确（有一次付款时支付宝插件调用不成功就是通过log分析出来的，原因是请求的IP地址不正确）

4、 使用不同的网络（WIFI/移动/联通/电信）及接入点（cmwap/cmnet）进行定位

5、 使用不同的机型（MOTO/索爱/夏普/华为/联想/阿里云等）及不同的系统版本（1.6/2.1/2.2/2.3等）进行定位

不是所有的用户反馈都是BUG，但是用户也不会随便反馈问题，如果有用户反馈遇到了问题，要么就是产品体验做的不够好，要么就是用户操作有出入，再要么就是线上BUG。我们谁都不想出现线上BUG，但有测试时因为这样那样的原因，又不免有遗漏，所以但凡遇到用户反馈，我们QA或者相关项目组的童鞋都有义务想办法帮助用户解决问题。

首先要监视系统异常，自动通过短信

业务配置化 （某个具体的业务服务是否开启，开启哪些小分支 等都需要配置在数据表里，遇到运营事故可以修改配置表救急）

容灾措施

灰度发布

# MVP如何管理Presenter的生命周期，何时取消网络请求

可以给Presenter增加生命周期的方法，让Presenter和V层生命周期同步就可以做到了

页面退出取消网络请求

# Java为何引入泛型，泛型边界

**将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。**

泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法，各种容器类，如：List、Set、Map。

# Android内存优化（使用SparseArray和ArrayMap代替HashMap）

**1、HashMap**

 HashMap内部存储结构是使用哈希表的拉链结构（数组+链表），这种存储数据的方法叫做拉链法。

HashMap中默认的存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap对象时，即使里面没有任何元素，也要分别一块内存空间给它，而且，我们再不断的向HashMap里put数据时，当达到一定的容量限制时，HashMap的空间将会扩大，而且扩大后新的空间一定是原来的2倍。

**2、SparseArray**

 避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了**压缩的方式来表示稀疏数组的数据，从而节约内存空间**。

 SparseArray只能存储key为int类型的数据，同时SparseArray在存储和读取数据时候，使用的是二分查找法。

**3、ArrayMap**

 ArrayMap是一个<key,value>映射的[数据结构](http://lib.csdn.net/base/datastructure "算法与数据结构知识库")，它设计上更多的是考虑**内存的优化**，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值。它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作。

**4、使用**

 1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用。

 2、如果key类型为其它的类型，则使用ArrayMap。

# Arouter的原理
通过注解给每个Activity定义一个路由，添加到一个map集合中进行统一管理，跳转的时候通过路由找到对应的Activity然后在跳转。

# 进程间为什么不能直接进行通信

**进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符**）。

但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要[进程间通信( IPC：Inter Processes Communication )](http://baike.baidu.com/link?url=onUmRVBEvZGdNWGePdUzKeDs8YmyGC-vB3wscH9P6apmFoz6OZW9N8THi07FfrrUeSNFOvVS_Y_17dt3dFQA7K)。

**进程间通信的目的：**

*   数据传输：一个进程需要将它的数据发送给另一个进程。
*   通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 
*   资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 
*   进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

# Debug跟Release的APK的区别

既然Debug和Release仅仅是编译选项的不同，那么为什么要区分Debug和Release版本呢？      Debug和Release，在我看来主要是针对其面向的目标不同的而进行区分的。Debug通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不做任何优化，以为开发人员提供强大的应用程序调试能力。而Release通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。

# 对谷歌新推出的Room架构
Room提供了一个SQLite之上的抽象层，使得在充分利用SQLite功能的前提下顺畅的访问数据库。

对于需要处理大量结构化数据的App来说，把这些数据做本地持久化会带来很大的好处。常见的用例是缓存重要数据块。这样当设备无法连网的时候，用户仍然可以浏览内容。而用户对内容做出的任何改动都在网络恢复的时候同步到服务端。

核心framework内置了对SQL的支持。虽然这些API很强大，但是都很低级，使用起来很花时间和精力：

*   没有编译时的SQL查询检查机制。当数据表发生改变的时候，需要手动更新受影响的SQL查询。这个过程既耗时又容易出错。

*   需要写很多公式化的代码在SQL查询与Java对象之间转换。

Room处理了这些相关的事情，同时提供了SQLite之上的抽象层。

#  setX setTranslationX 的区别

通过源码，可以发现, 实际上就是调用了setTranslationX，默认情况下，getX() 等于 mLeft，即View左边缘距离父容器左边缘的距离；

```
 public void setX(float x) {
      setTranslationX(x - mLeft);
 }

 public float getX() {
        return mLeft + getTranslationX();
 }

```

translationX 表示相对于原始位置的X轴上的移动距离，比如：原始mLeft=100，设置translation为-50后，getX(): 返回50; getTranslation返回-50；

# Picasso传入的Activity和Application的context的区别

picasso默认情况下会使用全局的ApplicationContext，即开发者传进去Activity，picasso也会通过activity获取ApplicationContext。

```
/** Start building a new {@link Picasso} instance. */
public Builder(Context context) {
  if (context == null) {
    throw new IllegalArgumentException("Context must not be null.");
  }
  this.context = context.getApplicationContext();
}
```
# 数据库的升级，表结构的修改
在onUpgrade中
更新语句一条一条写，不能并列写
`db.execSQL("ALTER TABLE note ADD COLUMN marktes integer");//增减一项 保存用户数据`


# 常见的排序算法，手写二分查找，二分查找的复杂度分析

O(log2n)

# 设计一个多线程，可以同时读，读的时候不能写，写的时候不能读(读写锁)

在对数据进行读写的时候，为了保证数据的一致性和完整性，需要读和写是互斥的，写和写是互斥的，但是读和读是不需要互斥的，这样读和读不互斥性能更高些
![](http://ou21vt4uz.bkt.clouddn.com/interview/lock/readWriteLock.png)

# 断点续传

[okhttp下载文件断点续传(转)实测有用](http://www.jcodecraeer.com/a/chengxusheji/java/2017/0907/8484.html)

断点续传就是从停止的地方重新下载。
断点：线程停止的位置。
续传：从停止的位置重新下载。
用代码解析就是：
断点 ： 当前线程已经下载完成的数据长度。
续传 ： 向服务器请求上次线程停止位置之后的数据。
每当线程停止时就把已下载的数据长度写入记录文件，当重新下载时，从记录文件读取已经下载了的长度。而这个长度就是所需要的断点。

续传的实现也简单，可以通过设置网络请求参数，请求服务器从指定的位置开始读取数据。

通过设置Request对象的header方法的**RANGE**就可以告知服务器端开始下载的节点

在onResponse 回调方法中我们可以看到，当我们在之前的head中添加了**RANGE**字段，但是如果返回的http code不是206是，我们就可以确定所请求的文件是不支持断点下载的。

RandomAccessFile来实现从指定位置给文件写入数据的功能。

 断点续传：记录上次上传（下载）节点位置，下次接着该位置继续上传（下载）。多线程断点续传下载则是根据目标下载文件长度，尽可能地等分给多个线程同时下载文件块，当各个线程全部完成下载后，将文件块合并成一个文件，即目标文件。多线程断点续传不仅为用户避免了断网等突发事故需要重新下载浪费流量的尴尬局面，也大大提高了下载速率，当然，不是线程越多越好，网络带宽才是硬道理！以下为原理图：

![](http://www.jcodecraeer.com/uploads/userup/14445/1FZGST9-3R3-1.png)

java，android中可以使用RandomAccessFile类生成一个同目标文件大小的占位文件，以便于各个线程可以同时操作该文件，并写入各线程实时下载的数据。
`
tmpAccessFile.seek(finalStartIndex);// 文件写入的开始位置.
`

# Binder机制：Binder内核所在的进程是如何找到到Server跟Client进行通信的

**Binder运行的实例解释**

首先我们看看我们的程序跨进程调用系统服务的简单示例，实现浮动窗口部分代码：

```
//获取WindowManager服务引用
WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);  
//布局参数layoutParams相关设置略...
View view=LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, null);  
//添加view
wm.addView(view, layoutParams);
```

**注册服务(addService)**：在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册（即让ServiceManager管理）。这一步是系统自动完成的。

**获取服务(getService)**：客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，通常是Service引用的代理对象，对数据进行一些处理操作。即第2行代码中，得到的wm是WindowManager对象的引用。

**使用服务**：通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。即第6行调用WindowManager的addView函数，将触发远程调用，调用的是运行在systemServer进程中的WindowManager的addView函数。

**使用服务的具体执行过程**

![](https://user-gold-cdn.xitu.io/2017/3/28/f2362dff502cab3871f6220ab5f336a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1.  client通过获得一个server的代理接口，对server进行调用。
2.  代理接口中定义的方法与server中定义的方法时一一对应的。
3.  client调用某个代理接口中的方法时，代理接口的方法会将client传递的参数打包成Parcel对象。
4.  代理接口将Parcel发送给内核中的binder driver。
5.  server会读取binder driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回。
6.  整个的调用过程是一个同步过程，在server处理的时候，client会block住。**因此client调用过程不应在主线程。**

# 一个线程能否创建多个Handler，Handler跟Looper之间的对应关系

一个线程中有n个handler，但只有一个Looper和MessageQueue

# ArrayList跟HashMap是够线程安全，如何保证线程安全

ArrayList跟HashMap不是线程安全的，线程安全的可以是hashtable，cucerrentHashMap，通过锁实现线程安全

# Volley返回数据量比较大的请求时怎么办

* 1.改成多次请求每次请求数据量小些，因为Volley适用于网络请求非常频繁但是数据量并不是特别大的。

* 2.BasicNetwork是volley处理返回response的默认实现，它是把server返回的流全部导入内存，你说，下载大数据会用它吗？ByteArrayPool只是一个小于4k的内村缓存池，它被只是用在了BasicNetwork的实现里。上传和BasicNetwork应该没有多大关系，volley也是可以上传大数据的，volley也是可以下载大数据的，只是你不要使用BasicNetwork，就行了

# ListView跟RecyclerView刷新数据原理，使用到的设计模式
一、ListView
![](http://ou21vt4uz.bkt.clouddn.com/interview/listview/listview-item-refrash.png)

Android RecyclerView局部刷新那个坑，RecyclerView局部刷新大家都遇到过，有时候还说会遇见图片闪烁的问题。

![](http://ou21vt4uz.bkt.clouddn.com/interview/listview/rcyclerview_item_refrash_bug.png)

# 适配如何做，有没有适配过全面屏

* 使用relativeLayout，不使用绝对布局，使用wrap_content,match_parent,dp,不使用px
* size限定符 layout_large,layout_sw600dp,屏幕方向限定符(横屏竖屏)，
* 使用.9图
* 使用备份位图，mdpi，hdpi,xhdpi,xxhpi,xxxdpi
* 动态设置图片尺寸

# Fragment跟Activity的通信方式，你知道几种？

* （一）Handler

* （二）广播

* （三）EventBus

* （四）接口回调（Fragment如何传递数据到 Activity）

* （五）Bundle和setArguments(bundle)（Activity 如何传递数据到 Fragment）

**a、如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法**

**b、如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作。**

**c、在Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作。**

# 内存泄露的种类

# ActivityA启动ActivityB时生命周期的变化
A：onCreate-》onStart-》onResume-》onPause
B：onCreate-》onStart-》onResume
A：onStop
B：onPause
A：onRestart-》onStart-》OnResume
B：onStop-》OnDestroy

# AMS是如何管理Activity的

# JVM中的GC回收机制

# 常见的跨进程通信方式，AIDL的实现原理

# APP以及Activity的启动流程

# Hook以及插桩技术

# 从长度为m的int数组中随机取出n个元素，每次取的元素都是之前未取过的，如何优化

## 方案一：将选择过的元素从原数组中通过splice方法进行删除

为了下次随机时不重复选取已经选择过的元素，我们将选择过的元素从原数组中通过splice方法进行删除，但这个splice方法操作的过程本身就是数组重新维护其元素索引的过程，这意味着被选择的元素之后的所有元素需要前移一个位置来重新生成一个紧凑的数组，可以想象如果我们取走了原数组中的第1个元素，那么之后的99 999个元素都需要发生变动来完成重组数组的操作，无疑有点耗时。

## 方案二：洗牌算法

既然要随机选取，那我可以先把数组的元素打乱先，然后要多少就从开始取多少就行了。一提到随机，自然想到洗牌算法，而关于洗牌算法已经有一个非常经典且高效的Fisher-Yates算法了，这个算法我之前有写过[一篇博客](http://www.cnblogs.com/Wayou/p/fisher_yates_shuffle.html)介绍过。

这个想法较之前的方法有点逆行的感觉，前面着重点是随机，所以每次都产生一个随机下标到原数组去取，现在是先将数组元素随机打乱，再去正常取。由于洗牌算法非常高效且省去了数组的重组，较之前性能应该有所提升。

细想还是存在问题，对于一个比较大的数组来说，不管你的洗牌算法多么高效（即使上面Fisher-Yates算法时间复杂度为O(n)），要随机整个数组也还是很庞大的工程的吧。

## 方案三：只取所需

那就是我们没有必要随机掉整个数组，在我们取完需要数量的元素后，可以将Fisher-Yates乱序方法中止掉！

思路是非常明显的了， 这样可以省下不少无意义的操作。

# **A解法**

## **2.1 常见解法有两种：**

```
1.间接获取--采用随机下标从已实例化的数组中取元素
2.直接获取随机数--然后一一排除

```

## **2.2 间接法逻辑分析**

*   第一步：将指定范围内的所有数循环放入数组arr中

*   第二步：使用随机下标从该数组中取值，去过的值，赋值为-1

*   第三步：每次取值时，根据取出来的值是否是 -1来判断该值是否已经取过

*   第四步：取过，则重新取值，没取过，直接拿来用

## **2.3 直接发逻辑分析**

给长度为m的数组arr，依次赋值，每次赋值前，都与前面已经赋值的数进行比较是否重复，若重复，则重复生成随机数赋值，若不存在，直接赋值。

## **2.4 两种方法实现代码如下**

![](http://ou21vt4uz.bkt.clouddn.com/interview/suanfa/n_m_1.png)

![](http://ou21vt4uz.bkt.clouddn.com/interview/suanfa/n_m_2.png)

# https是如何保证安全的，证书如何校验

# Android的签名机制，APK包含哪些东西

# 是否遇到过OOM，如何解决

某个应用程序内存泄露仅仅只会使自己进程被kill掉不会影响其他进程（如果是system_process等系统进程出现问题，就会造成系统重启），**另一方面**，系统为每一个应用程序分配了不同的内存上限，如果超过这个上限被视为内存泄露，从而被kill掉。
Dalvik Heap size因不同设备的RAM不同而有所差异，应用占用内存接近这个阀值，在尝试分配内存就会引起outofmemoryError的错误。

OOM产生可能的原因是因为：
* 1、加载大图片导致内存溢出
* 2、大量内存泄露

## 如何避免OOM

* **1.使用更加轻量的数据结构**

考虑使用ArrayMap/SpareseArray而不是传统的HashMap等数据结构，Android系统为移动系统设计的容器ArrayMap更加高效，占用内存更少，因为HashMap需要一个额外的实例对象来记录Mapping的操作。而SparesArray高效的避免了key和value的自动装箱，而且避免了装箱后的解箱。

* **2.避免在Android中使用Enum**

* **3.减少Bitmap对象的内存占用**
    Bitmap是一个消耗内存的大胖子，减少创建出来的Bitmap的内存占用很重要。一般有两种措施

（1）   inSampleSize:缩放比例，在把图片载入内存之前，我们需要计算一个合适的缩放比例，避免不必要的大图载入。
（2）   decode format:解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。

* **4.使用更小的图片**
    在设计图片资源的时候，我们要考虑图片是否存在可以压缩的空间，是否能使用更小的图片，使用小图在xml加载资源时就不会在初始化视图因为内存不足而发生InflationException,其根本原因就是发生了OOM。
* **5.缓存算法LRU**

* **6.避免在onDraw方法里面执行对象的创建**
    在onDraw这种频繁调用的方法要避免对象的创建操作，因为他会迅速增加内存的使用，引起频繁的gc，甚至内存抖动
* **7.StringBuilder**
    如果代码中有大量字符串拼接操作，使用StringBuilder代替"+"
* **8.避免对象的内存泄露**
	内存对象的泄露会导致不再使用的对象无法及时释放，不仅浪费了宝贵的内存空间，后续要分配内存的时候，空间不足造成OOM，一系列内存泄漏的场景


# 是否做过逆向

# 对JNI了解多少

# 手写单例(DCL)

# 是否写过so文件

# 热修复原理，如何进行dex替换的

# 内存泄露，如何检测以及检测的原理

# 点击Launcher打开微信和支付启动微信有什么区别

（a）android.intent.action.MAIN，表明该Activity可以作为APP入口启动。一个APP可以有多个入口，例如微信的主界面（用户点击进入），和微信的支付界面（第三方调用进入）

（b）android.intent.category.LAUNCHER，表明该Activity可在桌面显示（点击APP图标所触发的Activity）

当我们使用Android Studio创建一个工程并生成一个Activity时，经常可以在清单文件中看到如下的代码：

```
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
```

如果我们创建第二个Activity的话，标签里面默是没有action和category的，那么这里的android.intent.action.MAIN和android.intent.category.LAUNCHER有什么作用呢？

通过查阅API文档，了解到它们的作用如下：

* **android.intent.action.MAIN**：决定应用的入口Activity，也就是我们启动应用时首先显示哪一个Activity。 

* **android.intent.category.LAUNCHER**：表示activity应该被列入系统的启动器(launcher)(允许用户启动它)。Launcher是安卓系统中的桌面启动器，是桌面UI的统称。

action和category都是Intent的组成部分，前者表示意图的动作，后者表示意图的类别。所以对于上面这段话，我的理解是：
android.intent.action.MAIN表明了一个应用启动时首先启动这个Activity的动作。怎样启动呢？

android.intent.category.LAUNCHER告诉了我们动作是什么：通过**App的启动器**（我个人理解成桌面的图标）来启动。

## 破坏一：去掉所有Activity的android.intent.action.MAIN

如果我们去掉所有Activity的android.intent.action.MAIN会怎么样呢？很简单，由于android.intent.action.MAIN决定了入口Activity，去掉它之后应用就找不到入口，不知道启动哪一个Activity。如果把Activity比喻成Android应用的面孔，那么此时Android应用就没脸见人了。

运行按钮旁边的选择下拉菜单就会提示当前应用有错误： 
![这里写图片描述](https://img-blog.csdn.net/20160722121517050)

如果强行运行的话就会启动失败： 
![这里写图片描述](https://img-blog.csdn.net/20160722121413112)

但是有一个特别的地方，打开手机设置，点击“应用管理”，发现了吗？已安装的应用中是有“我的应用”的。也就是说它能够成功安装，但是由于缺少了入口，所以桌面是看不到它的。

![这里写图片描述](https://img-blog.csdn.net/20160722220645148)

## 破坏二：去掉所有Activity的android.intent.category.LAUNCHER

由破坏一可知，我们必须有一个入口Activity，所以我们把android.intent.action.MAIN还给MainActivity。然后我们只需去掉MainActivity中的android.intent.category.LAUNCHER。

```
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
            </intent-filter>
        </activity>
        <activity android:name=".SecondActivity"></activity>
```

前面讲过，android.intent.category.LAUNCHER决定Activity是否列入系统的启动器，那么此时我们没有一个Activity拥有这句代码，也就是说没有一个Activity在启动列表中。结果相信你也猜到了，编译器会直接提示有错，截图就跟破坏一的一样。此时，打开手机设置中的“应用管理”，可以看到应用成功安装了，但是由于没有App的启动器，所以桌面上找不到。

## 破坏三：多个Activity拥有android.intent.action.MAIN

从破坏一和破坏二可以看到，一个应用要写正常运行是需要至少一个Activity同时拥有android.intent.action.MAIN和android.intent.category.LAUNCHER的。我们在MainActivity都加上它们，但同时我们也在SecondActivity中加入android.intent.action.MAIN：

```
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name = "android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <activity android:name=".SecondActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
            </intent-filter>
        </activity>
```

结果会怎么样呢？运行之后我们可以看到桌面生成了一个“我的应用”的图标，这个应用只有一个Activity，就是MainActivity。可见SecondActivity根本没有露脸。这也很好理解，它缺少了android.intent.category.LAUNCHER，不是App的启动器，点击图标启动的并不是它，我们要想看到它只能通过跳转了。

![这里写图片描述](https://img-blog.csdn.net/20160722121750742)

![这里写图片描述](https://img-blog.csdn.net/20160722121823415)

## 破坏四：多个Activity同时拥有android.intent.action.MAIN和android.intent.category.LAUNCHER

我们给SecondActivity也加上android.intent.category.LAUNCHER，这样两个Activity几乎没有差别了。同时，我们给SecondActivity再加上一句：android:label=”我的应用2”，原因后面就会知道了。

```
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name = "android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <activity android:name=".SecondActivity"
            android:label="我的应用2">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name = "android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
```

通过前面学习我们已经知道，这相当设置了两个入口啊，那么Android应用面对分岔路会怎么办呢？我们把破坏三中生成的“我的应用”卸载掉，再运行App。这时候神奇的事情发生了！桌面上同时生成了两个图标，一个是“我的应用”，另一个是“我的应用2”。

![这里写图片描述](https://img-blog.csdn.net/20160722122501273)

点击“我的应用”，我们可以看到是MainActivity，嗯，跟之前一样。那么“我的应用2”呢？点击它你会看到SecondActivity。

![这里写图片描述](https://img-blog.csdn.net/20160722122651148)

由此我们可以知道，当一个Android应用中有一个以上的入口Activity时，安装App时会生成相应个数的图标（你可以使用android：icon设置不同图标）。至于图标的名称，如果你没有为每一个Activity都设置的话，那么就会使用应用的名称，比如MainActivity就是这样。但是要注意，这些图标代表都是同一个应用！不信的话，你在你的手机设置中打开“应用管理”，在“已安装”中就可以看到这有一个“我的应用”，并没有“我的应用2”。

![这里写图片描述](https://img-blog.csdn.net/20160722122804180)

除此之外，你还可以搞最后一个破坏来验证这一点：通过拖拽图标的方式卸载应用，不管拖拽的是哪一个图标，它们最后都是一起消失的。

# 逆序一个字符串，不能调用String的reverse方法(考察编码风格)
```
public static String reverseString(String str) {
    if (str.isEmpty()) {
        return "";
  }
    try {
        char[] data = str.toCharArray();
 int i = 0;
 int j = str.length() - 1;
 while (i < j) {
            char tmp = data[i];
  data[i] = data[j];
  data[j] = tmp;
  i++;
  j--;
  }

        return String.valueOf(data);
  } catch (Exception e) {
        return "";
  }
}
```

# 组件化原理，模块化机制

# 没有给权限如何定位，特定机型定位失败，如何解决

GPS就是精准定位！

蓝牙、移动信号、wifi都是能定位的。就是基于网络定位，但是不太准，没有GPS定位那么准。

android的定位权限就是GPS定位，但是只要你有网络请求，就能得到你的大概范围,原理搜集你的wifi节点信息和你的手机基站信息来定位。

**通过GPS定位，较精确，也比较耗电，而网络定位精度不高，省电**。

**1、判断版本，如果6.0以下，那么便不需要获取权限。**
**2、若是6.0以及以上的话，那么便去判断是否已经授权，若是没有授权，那么便会去申请授权。若是已经授权，那么便直接执行我们的操作。**
然后调用shouldShowRequestPermissionRationale方法，若是返回false，说明

1、点击了“不再提醒”。

2、该app本身没有权限，被关闭。

那么我们就可以提醒用户去设置界面手动开启权限。

gps，网络和基站


# 同步跟异步机制(是业务上的，不知道他想问什么)

# 线程池中核心线程数跟最大线程数如何定义

# StringBuffer跟StringBuilder之间的区别

# 并发相关，各种锁

# View的绘制流程，事件分发

# Hashmap,Arraymap，SparseArray

# 四种引用

# MVP跟MVC的区别

# Listview跟RecycledView之间的区别

# Service相关，startService以及bindService

# Fragment不同于Activity的生命周期

# 生产者消费者问题：一对多，多对多情况
生产者与消费者问题主要解决的是同步问题：

*   当目标对象已经为0，或已经不存在时，这时消费者就不能再继续消费了，所以要让生产者先生产目标对象。
*   当目标对象达到一定数量时应停止生产了，这时生产者应停止继续生产，需要消费者先进行消费目标对象。

可知三者关系，生产者与消费者共同作用于目标对象，但生产者与消费者之间又存在先后关系。

生产者——>生成一定量的数据放到缓冲区中，然后重复此过程； 
消费者——>在缓冲区消耗这些数据。 
而生产者-消费者之间存在三种关系,即 
生产者与生产者之间是互斥关系； 
消费者与消费者之间是互斥关系； 
生产者与消费者之间是同步与互斥关系。

构建生产者-消费者模型，是线程间协作的思想，工作线程的协助是为了让UI线程更好的完成工作，提高用户体验。比如，下面的一种情况： 

![这里写图片描述](http://img.blog.csdn.net/20160226100603748) 

这个是我们平常开发中很常见的一种情景，大量的图片资源的访问，因为图片访问是一个网络耗时的任务，如果完全交由UI线程去处理，显然用户体验不佳，只能在适配器(Adapter)中的getView()方法做网络异步请求。很多人，都通过第三方框架来实现异步的效果，虽然图片加载的处理要比我们好很多，但是用户体验的效果还是不佳。在比如说像图片的那样，如何做到异步加载，这都是由工作线程协助UI线程去完成的，使用生产者-消费者模型则有助于提高的用户体验。 

**1.生产者-消费者模型的构造**

![这里写图片描述](http://img.blog.csdn.net/20160519144118166)

在这里，我可以提前准备一个队列或者集合，作为缓冲区，把用户拖动作为生产者，因为用户一拖动就会调度getView()方法，那么我们在getView()方法就像缓冲区存放网络请求的任务进去。那么，消费者就是我们的工作线程，我们在工作线程将任务取出，并且加载到内存中，由Hander来切换到UI线程中，完成更新。更为主要的是，如果将任务放入队列中或者什么时间取出任务；从队列中取出哪个任务；什么时候执行任务；怎样执行任务……这个决策权完全由我们掌握，这样，我们就把UI线程的压力给释放出来了。

我们可以采用java并发库里面的工具ConcurrentLinkedQueue来充当我们的队列，当然这个队列就是真的队列，采用的是先进先出的行为，我们就不能对任务的取出的顺序进行操作了，也就达不到倒序加载或者随机加载了的效果了。但是代码非常的简洁。

```
//队列
private ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<String>();

//生产者
    if(!queue.contains(Images.imageThumbUrls[position])){
                        queue.offer(Images.imageThumbUrls[position]);
                    }
//消费者，这里虽然不是原子操作，但是考虑到只有一个线程对它操作，所以就没有同步了。
    if(!queue.isEmpty()){
                                String url = queue.poll();
                                if(mHandler != null){
                                    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_IMAGE, url));
                                }
                            }

```

ConcurrentLinkedQueue队列的特点就是内部采用了CAS算法，是一种非阻塞的同步队列，所以就没必要我们对其加锁了。所以对ConcurrentLinkedQueue不熟悉的话，可以看这篇文章[并发编程网](http://www.infoq.com/cn/articles/ConcurrentLinkedQueue/)脑补下。

# 常见的设计模式，并选择一种描述一下
[观察者](https://blog.csdn.net/ljd2038/article/details/51262518)

# Scroller的使用

scrollTo()方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。而scrollBy()方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直向右下方移动。

只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。 
Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤： 
1\. 创建Scroller的实例 
2\. 调用startScroll()方法来初始化滚动数据并刷新界面 
3\. 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑

* 首先在ScrollerLayout的构造函数里面我们进行了上述步骤中的第一步操作，即创建Scroller的实例，由于Scroller的实例只需创建一次，因此我们把它放到构造函数里面执行。另外在构建函数中我们还初始化的TouchSlop的值，这个值在后面将用于判断当前用户的操作是否是拖动。 
接着重写onMeasure()方法和onLayout()方法，在onMeasure()方法中测量ScrollerLayout里的每一个子控件的大小，在onLayout()方法中为ScrollerLayout里的每一个子控件在水平方向上进行布局。如果有朋友对这两个方法的作用还不理解，可以参照我之前写的一篇文章 [Android视图绘制流程完全解析，带你一步步深入了解View(二)](http://blog.csdn.net/guolin_blog/article/details/16330267) 。 

* 接着重写onInterceptTouchEvent()方法， 在这个方法中我们记录了用户手指按下时的X坐标位置，以及用户手指在屏幕上拖动时的X坐标位置，当两者之间的距离大于TouchSlop值时，就认为用户正在拖动布局，然后我们就将事件在这里拦截掉，阻止事件传递到子控件当中。 
那么当我们把事件拦截掉之后，就会将事件交给ScrollerLayout的onTouchEvent()方法来处理。如果当前事件是ACTION_MOVE，说明用户正在拖动布局，那么我们就应该对布局内容进行滚动从而影响拖动事件，实现的方式就是使用我们刚刚所学的scrollBy()方法，用户拖动了多少这里就scrollBy多少。另外为了防止用户拖出边界这里还专门做了边界保护，当拖出边界时就调用scrollTo()方法来回到边界位置。 
如果当前事件是ACTION_UP时，说明用户手指抬起来了，但是目前很有可能用户只是将布局拖动到了中间，我们不可能让布局就这么停留在中间的位置，因此接下来就需要借助Scroller来完成后续的滚动操作。首先这里我们先根据当前的滚动位置来计算布局应该继续滚动到哪一个子控件的页面，然后计算出距离该页面还需滚动多少距离。接下来我们就该进行上述步骤中的第二步操作，调用startScroll()方法来初始化滚动数据并刷新界面。startScroll()方法接收四个参数，第一个参数是滚动开始时X的坐标，第二个参数是滚动开始时Y的坐标，第三个参数是横向滚动的距离，正值表示向左滚动，第四个参数是纵向滚动的距离，正值表示向上滚动。紧接着调用invalidate()方法来刷新界面。 

* 现在前两步都已经完成了，最后我们还需要进行第三步操作，即重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。

# Gradle生命周期
* 1.初始化阶段，会去读取根工程中setting.gradle中的include信息，决定有哪几个工程加入构建， 创建project实例，比如下面有三个工程： include ':app', ':lib1', ':lib2 

* 2.配置阶段，会去执行所有工程的build.gradle脚本，配置project对象，一个对象由多个任务组成， 此阶段也会去创建、配置task及相关信息。 

* 3.运行阶段，根据gradle命令传递过来的task名称，执行相关依赖任务

settings.gradle

```
println '=====在初始化阶段执行===='

```

build.gradle

```
println '=====在配置阶段执行===='

task configured {
    println '=====也在配置阶段执行====='
}

task test << {
    println '======运行阶段执行====='
}

task testBoth {
    doFirst {
      println '======在task运行之前执行======'
    }
    doLast {
      println '======在task运行之后执行======'
    }
    println '======在配置阶段执行======'
}
```

# Java&Android关于Classloader源码解析
双亲委派机制

### Java
JVM 那样 **直接** 加载 class 文件和 jar 文件中的 class

### Android
[热修复入门：Android 中的 ClassLoader](https://jaeger.itscoder.com/android/2016/08/27/android-classloader.html)

Android 开发者官网上的 [ClassLoader](https://developer.android.com/reference/java/lang/ClassLoader.html) 的文档说明中我们可以看到，ClassLoader 是个抽象类，其具体实现的子类有 `BaseDexClassLoader` 和 `SecureClassLoader` 。

SecureClassLoader 的子类是 `URLClassLoader` ，其只能用来加载 jar 文件，这在 Android 的 Dalvik/ART 上没法使用的。

BaseDexClassLoader 的子类是 `PathClassLoader` 和 `DexClassLoader` 。

#### PathClassLoader

PathClassLoader 在应用启动时创建，从 data/app/… 安装目录下加载 apk 文件。

其有 2 个构造函数，如下所示，这里遵从之前提到的双亲委托模型：

```
public PathClassLoader(String dexPath, ClassLoader parent) {
    super(dexPath, null, null, parent);
}

public PathClassLoader(String dexPath, String libraryPath,
        ClassLoader parent) {
    super(dexPath, null, libraryPath, parent);
}

```

*   `dexPath` : 包含 dex 的 jar 文件或 apk 文件的路径集，多个以文件分隔符分隔，默认是“：”
*   `libraryPath` : 包含 C/C++ 库的路径集，多个同样以文件分隔符分隔，可以为空

PathClassLoader 里面除了这 2 个构造方法以外就没有其他的代码了，具体的实现都是在 BaseDexClassLoader 里面，其 dexPath 比较受限制，一般是已经安装应用的 apk 文件路径。

在 Android 中，App 安装到手机后，apk 里面的 class.dex 中的 class 均是通过 PathClassLoader 来加载的。

#### DexClassLoader

对比 PathClassLoader 只能加载已经安装应用的 dex 或 apk 文件，DexClassLoader 则没有此限制，可以从 SD 卡上加载包含 class.dex 的 .jar 和 .apk 文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的 dex 的加载。

# Python的class文件

# DCL中Volatile的作用，如何防止反射实例化单例对象

### 工作内存和主内存

计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。

　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。

### 指令重排
一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

**要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。**

**volatile关键字的两层语义**

　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

　　2）禁止进行指令重排序。

指令重排序会出现A线程执行初始化，但可能因为构造函数里面的操作太多了，所以A线程的uniqueInstance实例还没有造出来，但已经被赋值了。而B线程这时过来了，错以为uniqueInstance已经被实例化出来，一用才发现uniqueInstance尚未被初始化。 

# 抽象类能否实例化，理论依据是什么？
`Animal animal  = new Dog()`
抽象类其实是可以被实例化的，但是它的实例化方式并不是通过普通的new方式来创建对象，而是通过父类的引用来指向子类的实例间接地实现父类的实例化，因为子类在实例化之前，一定会先实例化它的父类。这样创建了继承抽象类的子类对象，也就把其父类（抽象类）给实例化了。

注意：接口与抽象类非常类似，但是它不可以被实例化，因为接口压根没有构造函数。

# 如何通过Gradle配置差异较大(20%差异)的多渠道包

# class文件如何转化成dex

dx工具是一种用来转换Java class成为DEX格式的工具。

# Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？

**同时需要stopService和bunBind，否则不会调用destroy**

### Service 的 onCreate() 可以执行耗时操作吗？

**Service 运行在主线程中，它并不是一个新的线程，也不是新的进程，所以并不能执行耗时操作**。

### 那如果要在 Service 中执行耗时操作，怎么做？

我想基本所有人都能想到使用 Thread，事实上我们也经常这么做。需要在主线程执行耗时操作，无非就是开一个线程，然后一阵混沌操作。当然，你还可以使用 `AysncTask` 或 `HandlerThread`来替代 Thread 创建线程。

当然没有问题，那还有其它更有意思的方式吗？

有，当然有，IntentService 就是一个不错的选择

### 生命周期的联动

Activity在调用bindService后没有主动调用unbindService，而ServiceConnectin会引用Activity，Activity就会存在Leak。

# JVM相关,DVM以及ART是如何进行优化的，具体步骤

1、ART与Dalvik最大的不同在于，在启用ART模式后，系统在安装应用的时候会进行一次预编译，在安装应用程序时会先将代码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行一次编译了，执行效率也大大提升。

2、ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这就是“时间换空间大法”。

3、预编译也可以明显改善电池续航，因为应用程序每次运行时不用重复编译了，从而减少了 CPU 的使用频率，降低了能耗。

# 长连接常见的库，短链接

**短连接**
连接->传输数据->关闭连接
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。

**长连接**
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

**http的长连接**
HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。

**什么时候用长连接，短连接？**
 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。

而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

总之，长连接和短连接的选择要视情况而定。

# 静态同步锁与普通同步锁的区别

### 方法锁（synchronized修饰方法时）

通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。

synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，**方法一旦执行，就独占该锁**，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中**至多只有一个**处于可执行状态，从而有效避免了类成员变量的访问冲突。

### 对象锁（synchronized修饰方法或代码块）

当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁） 　　 　　　 　

Java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，**方法抛异常的时候，锁仍然可以由JVM来自动释放。**　

对象锁的两种形式：

```
public class Test
{
    // 对象锁：形式1(方法锁)
    public synchronized void Method1()
    {
        System.out.println("我是对象锁也是方法锁");
        try
        {
            Thread.sleep(500);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }

    }

    // 对象锁：形式2（代码块形式）
    public void Method2()
    {
        synchronized (this)
        {
            System.out.println("我是对象锁");
            try
            {
                Thread.sleep(500);
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }

    }
 ｝

```

### synchronized 修饰静态的方法或代码块

　　由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都**只有一份**。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。
　**对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。**　 

类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。　 　　

java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是［类名.class］的方式。

```
public class Test
{
　　 // 类锁：形式1
    public static synchronized void Method1()
    {
        System.out.println(＂我是类锁一号＂);
        try
        {
            Thread.sleep(500);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }

    }

    // 类锁：形式2
    public void Method２()
    {
        synchronized (Test.class)
        {
            System.out.println(＂我是类锁二号＂);
            try
            {
                Thread.sleep(500);
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            }

        }

    }
｝
```

# 直接在Activity中创建一个thread跟在service中创建一个thread之间区别

（1）若我们直接在Activity中新开一条线程来做耗时操作，当该Activity退出到桌面或其他情况时将成为一个**后台进程**。

（2）若我们在Service中新启动线程，则此时Android会依据进程中当前活跃组件重要程度，将其判断为**服务进程**，优先级比（1）高。

# Service和线程的区别
因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。

### 使用场景
需要在与页面交互去进行耗时处理可以在Activity中创建线程，页面的关闭操作也停止

不需要与用户的交互耗时操作可以在Service中创建线程，并且这个耗时操作与页面的关闭打开（生命周期无关）

# View的生命周期

## 生命周期的方法
1.  Creation（创建）

*   Constructors（构造函数）：有一种形式的构造函数会在View在代码中被创建时调用，另一种形式的构造函数会在View从layout加载出来时被调用。
    第二种形式的构造函数会解析和应用layout文件中定义的任何属性。
*   onFinishInflate()：该方法当View及其子View从XML文件中加载完成后会被调用。

1.  Layout（布局）

*   onMeasure(int, int)：该方法在计算当前View及其所有子View尺寸大小需求时会被调用。
*   onLayout(boolean, int, int, int, int)：该方法在当前View需要为其子View分配尺寸和位置时会被调用。
*   onSizeChanged(int, int, int, int)：该方法在当前View尺寸变化时被调用。

1.  Drawing（绘制）

*   onDraw(android.graphics.Canvas)：该方法在当前View需要呈现其内容时被调用。

1.  Event processing（事件处理）

*   onKeyDown(int, KeyEvent)：该方法在一个物理按键事件发生时被调用。
*   onKeyUp(int, KeyEvent)：该方法在一个物理按键弹起事件发生时被调用。
*   onTrackballEvent(MotionEvent)：该方法在一个轨迹球运动事件发生时被调用。
*   onTouchEvent(MotionEvent)：该方法在一个触摸屏幕运动事件发生时被调用。

1.  Focus（聚焦）

*   onFocusChanged(boolean, int, android.graphics.Rect)：该方法在当前View获得或失去焦点时被调用。
*   onWindowFocusChanged(boolean)：该方法在包含当前View的window获得或失去焦点时被调用。

1.  Attaching（附上）

*   onAttachedToWindow()：该方法在当前View被附到一个window上时被调用。
*   onDetachedFromWindow()：该方法在当前View从一个window上分离时被调用。
*   onVisibilityChanged(View, int)：该方法在当前View或其祖先的可见性改变时被调用。
*   onWindowVisibilityChanged(int)：该方法在包含当前View的window可见性改变时被调用。

上述方法是View生命周期中涉及到的比较重要的一部分，View类中包含了很多的方法和属性，有兴趣的话各位可以自己研究一下。

## 生命周期函数调用顺序

1.  View默认为可见的，不是默认值时先调用onVisibilityChanged()，但是此时该View的尺寸、位置等信息都不知道。
2.  可见性改变后才是调用带有两个参数的构造函数，当然，如果该View不是在layout中定义的话，会调用一个参数的构造函数。
3.  从XMl文件中inflate完成（onFinishInflate()）。
4.  将View加到window中（View是gone的，那么View创建生命周期也就结束）。
5.  测量view的长宽（onMeasure()）。
6.  定位View 在父View中的位置（onLayout()），若View是invisible，则View的创建生命周期结束。
7.  绘制View的content（onDraw()），只有可见的View才在window中绘制。
8.  View的销毁流程和可见性没有关系。

综上所述：View的关键生命周期为：

```
[改变可见性] --> 构造View() --> onFinishInflate() --> onAttachedToWindow() --> onMeasure() --> onSizeChanged() --> onLayout() --> onDraw() --> onDetackedFromWindow()
```
# View的绘制流程跟事件分发

# Activity跟Window之间的关系

# 对C跟JNI是否熟悉

# 热修复原理，插件化是如何进行加载插件的

# Java中的锁，各种同步方式之间的区别

Synchronize 和 Lock 
Synchronize:不可中断，非公平，适合简单的少量同步
ReentrantLock：可中断，公平，适合复杂的大量同步

# ANR在四大组件中的时间，场景

## 出现场景

*   主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。
*   主线程中存在耗时的计算
*   主线程中错误的操作，比如Thread.wait或者Thread.sleep等

Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框

*   应用在**5秒**内未响应用户的输入事件（如按键或者触摸）
*   BroadcastReceiver未在**10秒**内完成相关的处理

## 如何避免

基本的思路就是将IO操作在工作线程来处理，减少其他耗时操作和错误操作

*   使用[AsyncTask](http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/ "AsyncTask")处理耗时IO操作。
*   使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。
*   使用[Handler](http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/ "Handler")处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。
*   Activity的onCreate和onResume回调中尽量避免耗时的代码
*   BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。

## Anr场景分析

**1.使用命令导出anr日志**

```
adb pull /data/anr/traces.txt  ~/Desktop/

```

# OOM，如何避免

# 内存泄露原理，如何避免

# MVC跟MVP之间的区别

# ListView针对多种item的缓存是如何实现的
每一种item对应一个RecycleBin

# Android绘制二维跟三维的View的区别

OpenGL就是用来绘制三维图形的技术手段，当然OpenGL并不仅限于展示静止的三维图形，也能用来播放运动着的三维动画。不管是三维图形还是三维动画，都是力求在二维的手机屏幕上面展现模拟的真实世界场景

# 是否了解硬件加速

# ListView是如何实现对不同type的item的管理的

在getView()中需要将不同布局进行缓存和适配，系统在判断是否有convertView时，会自动去调用getItemViewType (int position) ，查看是否已经有缓存的该类型的布局，从而进入if(convertView == null)和else{}的判断。

# Android中IPC方式，各种方式优缺点，为什么选择用Binder

# 主流的热修复框架流派，原理，是否研究过classloader源码

# Android为什么要设计两种classloader，为什么不用一种，通过type来区分

# Bundle传递数据为什么需要序列化
一. 先说说什么是序列化——_ 序列化，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。_

二. 那么为什么要序列化？

序列化的原因基本三种情况： 

1.永久性保存对象，保存对象的字节序列到本地文件中；

2.对象在网络中传递； 

3.对象在IPC间传递。

# 手写一个快排，分析原理

# 广播传输的数据是否有限制，是多少，为什么要限制？

（参见[Activity之间传递数据的方式](http://blog.csdn.net/rflyee/article/details/47431633)）

Intent在传递数据时是有大小限制的，这里官方并未详细说明，不过通过实验的方法可以测出数据应该被限制在1MB之内（1024KB），笔者采用的是传递Bitmap的方法，发现当图片大小超过1024（准确地说是1020左右）的时候，程序就会出现闪退、停止运行等异常(不同的手机反应不同)，因此可以判断Intent的传输容量在1MB之内。

**当传递数据量过大，比如list的size过大，会导致B无法启动。现象即启动失败，activityB的oncreate()都不会执行。**

**Activity之间传递数据一般通过以下几种方式实现：**

1\. 通过intent传递数据

2\. 通过Application

3\. 使用单例

4\. 静态成员变量。（可以考虑 `WeakReferences`）

5\. 持久化（sqlite、share preference、file等）

# Activity启动时生命周期是如何回调的？

# MVP.MVC.MVVM之间对比分析

# 组件化通讯:有几种通信方式，Arouter原理

# 插件化加载流程，原理

# 关于反射混淆，耗性能的解决方式

# 天猫七巧板布局原理

# 热修复流派，原理

# RecyclerView的itemdecoration如何处理点击事件

[RecyclerView ItemDecoration的进阶使用](https://juejin.im/entry/59cb9f14f265da06456d8fd7)

#### item的点击事件和长点击事件

该功能主要通过addOnItemTouchListener() 来实现。
自定义的一个触摸监听器，其实通过一个手势探测器 GestureDetectorCompat 来探测屏幕事件，然后通过手势监听器 SimpleOnGestureListener 来识别手势事件的种类，然后调用我们设置的对应的回调方法。 通过findChildViewUnder()可以知道我们点击的是哪个item，
同时我们调用 RecyclerView 的另一个方法 getChildViewHolder()，可以获得该 item 的 ViewHolder，最后再回调我们定义的虚方法 onItemClick() 就ok了，这样我们就可以在外部实现该方法来获得 item 的点击事件了。

# 单例模式如何修改数据

# android事件传递

**ListView里面嵌套一个Button以及在ListView里面嵌套一个ScrollerView让我说一下事件在dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent中的传递过程**

ViewGroup里面有个方法requestDisallowInterceptTouchEvent，通过此方法可以阻止父层的View截获touch事件。也就是当我们设置ScrollView.requestDisallowInterceptTouchEvent(true)，ScrollView不会拦截touch事件，并将其交由ListView处理

# 多线程

# JVM内存分布，Classloader

# 静态代理跟动态代理

# 线程的生命周期

在线程的生命周期中，它要经过**新建**(New)、**就绪**（Runnable）、**运行**（Running）、**阻塞**(Blocked)和**死亡**(Dead)**5种状态**。尤其是当线程启动以后，它不可能一直"霸占"着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换

1\. 新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值

2\. 就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行

3\. 运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态

4\. 阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态

5\. 死亡，

线程会以如下3种方式结束，结束后就处于**死亡状态**：

**① **run()或call()方法执行完成，线程正常结束。

**② **线程抛出一个未捕获的Exception或Error。

**③ **直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用

# 是否用过DataBinding

# 是否接触过JNI

# 对热修复跟插件化了解多少

# 对RN了解多少

# 二分查找

# 说下多态

# 编译期注解跟运行时注解

# 线程跟进程间通信

# Android中的IPC

# java中的传递

# equals跟==

# Picasso的存储

# 项目中的难点

# 项目中用到了哪些第三方

# MVC,MVVM,Clean架构

# 抽象类跟接口的区别，接口的默认修饰符

# Canvas.save()跟Canvas.restore()的调用时机

# 程序A能否接收到程序B的广播？接入微信支付的时候，微信是如何跟当前程序进行通信？

# 对Java.nio了解多少

# ConcurrentHashMap是如何实现分段锁？

# 现在需要遍历SD卡下所有的文件打印出后缀名为.txt文件名称，如何提高时间效率？

# 为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？

# Android4.0～8.0之间大的变化，如何处理？

# 说一下Measurespec这个类

# ViewHolder有什么用？
ViewHolder就是一个静态类，使用 ViewHolder 的关键好处是缓存了显示数据的视图（View），加快了 UI 的响应速度。
ViewHolder模式通过getView()方法返回的视图的标签(Tag)中存储一个数据结构，这个数据结构包含了指向我们要绑定数据的视图的引用，从而避免每次调用getView()的时候调用findViewById()）
缓存View的子view引用去避免不必要的对findViewById方法的调用

### 定义为static

静态内部类不需要持有外部对象的引用，我理解这个好处和holder也最好为static内部类差不多，不然有可能造成外部对象的内存泄露。

# Gradle的Flavor能否配置sourceset？

# 线程池核心线程数一般定义多少，为什么？

# Intentservice有什么用

IntentService是继承于Service并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。

# 弱引用什么时候被回收

# Android中提供了哪些类来帮忙处理线程
AsyncTask，HandlerThread，IntentService，ThreadPoolExecutor

*   FixedThreadPool
*   CachedThreadPool
*   ScheduledThreadPool
*   SingleThreadExecutor

# http的状态码，常见的请求头，http缓存协议https如何加密

# 多进程的优缺点，多线程的优缺点

###  多进程

**1\. 多进程优点**

*   每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；
*   通过增加CPU，就可以容易扩充性能；
*   可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系；
*   每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大

**2\. 多进程缺点**

*   逻辑控制复杂，需要和主程序交互；
*   需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算
*   多进程调度开销比较大；

* * *

### 多线程

**1\. 多线程的优点**

* 更好的资源利用率
* 更快的程序响应

**2\. 多线程缺点**

* 程序更复杂
* 更多资源消耗

# 热修复如何修复资源文件？

# 有没有遇到64k问题，为什么，如何解决？

# httpUrlconnection跟httpClient有什么区别

# 两个非基本数据类型数组： array1=[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,×11] array2=[x6,x3,x10,x5] 计算结果：[x6,x7,x8,x9,x1,x2,x3,x4,x10,x11,x5],写出你的算法

# 类的初始化过程

### 在对对象初始化的时候，java底层做了三件事情：

### 一、给对象的实例变量（非静态变量）分配空间，并且默认初始化

### 二、声明初始化，对象初始化块的初始化，按照代码的顺序从上到下依次执行

### 三、构造函数的初始化

1、一个实例变量在对象初始化的过程中会被赋值几次？

　　我们知道，JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值，这个赋值过程是没有办法避免的。如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。如果我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值了。如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值。也就是说，在Java的对象初始化过程中，一个实例变量最多可以被初始化4次。

* * *

　　2、类的初始化过程与类的实例化过程的异同？

　　类的初始化是指类加载过程中的初始化阶段对类变量按照程序猿的意图进行赋值的过程；而类的实例化是指在类完全加载到内存中后创建对象的过程。

* * *

　　3、假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？

　　我们知道，要想创建一个类的实例，必须先将该类加载到内存并进行初始化，也就是说，类初始化操作是在类实例化操作之前进行的，但并不意味着：只有类初始化操作结束后才能进行类实例化操作。

# 点击事件穿透原则

在编写xml时使用到RelativeLayout或FrameLayout时，如果布局有层次结构，会发现点击上层时会触发下层的事件，这有时候并不是我们想要的结果，我们只想点击上层的就只触发上层布局的事件而不影响下层的，这时可以在上层的布局中增加android:clickable="true"的属性，这样下层的事件就不会被触发了。

控件默认android:clickable="false"，是不会调用onTouchEvent事件，导致控件不消费事件就往上传，传给了父布局导致时间透传

# 线程池使用的是哪一种，使用原则

# LeakedCanary原理
![](https://upload-images.jianshu.io/upload_images/737949-cff06b0079bf09c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

# LinerLayout跟RelativeLayout的绘制原理

# Android新版本的一些新特性6.0,7.0,8.0

# 类的初始化顺序依次是（静态变量、静态代码块）>（变量、代码块）>构造方法

# 看了看项目提了问题如何进行优化

如何实现马蜂窝中的一个动画效果

# 软键盘顶起布局

# 组件化通信方案

# 聊聊RecyclerView，动画，缓存，数据绑定底层是如何实现的。

# 聊了聊我的开源项目实现原理

# View在屏幕中的移动底层是如何实现的
1.layout 方法

在 View 绘制的过程中，会调用 onLayout　方法来定位

2.LayoutParams

LayoutParams 保存了一个 View 的布局参数，通过改变 LayoutParams 来动态的修改一个布局的位置参数，从而达到改变 View 位置的效果。

3.scrollTo 与 scrollBy

这里其实 scrollTo 和 scrollBy 使用起来很简单，但是理解起来稍微复杂一点。scrollTo 是直接移动到指定的坐标，而 scrollBy 是根据偏移量进行相对移动。但是需要注意的是，这两个都不是直接移动 View ，而是移动 View 中的 content ,比如 textView 中移动的是文字，imagView 中移动的是图片，移动的是内容，而不是本体。所以，我们应该在想要移动的 View 的父布局中去使用它，用它来移动 ViewGroup 中的子 View。

4.Scroller

Scroller 的内部其实也是用 scrollTo 方法来实现的，但是**它可以根据需要移动的总距离，以及设置的移动时间，计算出每一次需要移动的距离，然后不断的进行移动，这样就实现了一个动画的效果**。

# Binder跟Socket之间的区别，什么时候用哪一个，Binder的底层实现

# Activity,Window跟View之间的关系

# setContentView都干了啥

# Activity的启动模式

# MVC跟MVP之间的区别

# 算法：将一个有序数组去重得到一个新数组(空间复杂度为O(N))
```
public static int[] removeDuplicates2(int[] nums) {
    if (nums.length == 0 || nums.length == 1)
        return nums;
 int index = 0;
 int[] array = new int[nums.length];
 for (int i = 1; i < nums.length; i++) {
        if (nums[index] != nums[i]) {
            index++;
  nums[index] = nums[i];
  array[index] = nums[i];
  }
    }
    return Arrays.copyOfRange(nums,0,index+1); }
```

# LruCache底层实现

# Hashmap的hash算法

# Bitmap在decode的时候申请的内存如何复用，释放时机

## Bitmap加载图片

Bitmap的加载离不开BitmapFactory类，关于Bitmap官方介绍： 
`Creates Bitmap objects from various sources, including files, streams, and byte-arrays.`

BitmapFactory类提供了四类方法用来加载Bitmap：

1.  **decodeFile()**，从文件系统加载。
2.  **decodeResource()**，资源文件中加载。
3.  **decodeStream()**，从输入流加载。
4.  **decodeByteArray()**，从字节数组中加载。

**注意**：查看源码可以发现，**decodeFile()**和**decodeResource()**间接调用**decodeStream()**。

## Bitmap的内存位置

在Android3.0之前：**Bitmap的像素数据存放在Native内存，而Bitmap对象本身则存放在Dalvik Heap中。**

从Android3.0开始：**Bitmap的内存就全部在Dalvik Heap里了 。**

## Bitmap的内存回收

在Android3.0之前，需要**使用Bitmap.recycle()进行Bitmap的内存回收。**

从Android3.0开始，不需要手动回收Bitmap了。

## Bitmap的内存复用

从Android3.0开始，在Bitmap中引入了一个新的字段**BitmapFactory.Options.inBitmap**，设置此字段为true后，**解码方法会尝试复用一张存在的Bitmap**。这意味着Bitmap的内存被复用，避免了内存的回收及申请过程，显然性能表现更佳。

Android4.4(API 19)之前只有格式为jpg、png，同等宽高（要求苛刻），inSampleSize为1的Bitmap才可以复用。

从Android4.4(API 19)开始**被复用的Bitmap的内存大于需要新申请内存的Bitmap的内存**就可以了。

### 使用缓存

#### LruCache+DiskLruCache

出于对性能和app的考虑，我们肯定是想着第一次从网络中加载到图片之后，能够将图片缓存在内存和sd卡中，这样，我们就不用频繁的去网络中加载图片，可以很好地控制内存问题。

一般都会考虑使用LruCache+DiskLruCache，**LruCache作为Bitmap在内存中的存放容器，在sd卡则使用DiskLruCache来统一管理磁盘上的图片缓存**。

#### SoftReference+inBitmap

之前提到，可以采用LruCache作为存放Bitmap的容器，而在LruCache中有一个方法值得留意，那就是entryRemoved()，按照文档给出的说法，在LruCache容器满了需要淘汰存放其中的对象腾出空间的时候会调用此方法。

*   注意：**这里只是对象被淘汰出LruCache容器，但并不意味着对象的内存会立即被Dalvik虚拟机回收掉**。

此时可以在此方法中将Bitmap使用SoftReference包裹起来，并用事先准备好的一个HashSet容器来存放这些即将被回收的Bitmap，有人会问，这样存放有什么意义？

之前我们提到**将inmutable设置为true，Bitmap的内存可以被复用**，当然肯定要满足之前所说的条件。

解码方法**对图片进行decode的时候会检查内存中是否有可复用的Bitmap**，避免我们频繁地去SD卡上加载图片而造成系统性能的下降，毕竟从直接从内存中复用要比在SD卡上进行IO操作的效率要高很多。

## Bitmap的像素格式

1.**ALPHA_8**：颜色信息**只由透明度组成，占8位**。

2.**ARGB_4444**：颜色信息**由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位**。

3.**ARGB_8888**：颜色信息**由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位**。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。

4.**RGB_565**：颜色信息**由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位**。

通常我们优化Bitmap时，当需要做性能优化或者防止OOM，**我们通常会使用RGB_565，因为ALPHA_8只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444显示图片不清楚，Bitmap.Config.ARGB_8888占用内存最多**。

## Android加载大量图片内存溢出解决方案：

1.  尽量不要使用setImageBitmap或setImageResource或BitmapFactory.decodeResource来设置一张大图，因为这些函数在完成decode后，最终都是通过java层的createBitmap来完成的，需要消耗更多内存，可以通过BitmapFactory.decodeStream方法，创建出一个bitmap，再将其设为ImageView的 source
2.  使用BitmapFactory.Options对图片进行压缩(上述第二部分)
3.  运用Java软引用，进行图片缓存，将需要经常加载的图片放进缓存里，避免反复加载

# 注解如何实现一个findViewById

#### 既然用到注解，我们首先要创建个注解，下面贴上我的代码。

```
@Target(ElementType.FIELD) //注解目标为域
@Retention(RetentionPolicy.RUNTIME) //运行时注解
public @interface BindView {
    int value() default 0;//当前注解只需要一个值，所以我们用value 默认值为0
}
```
这里我创建了一个名为BindView的注解，使用了默认的成员value并赋默认值为0，通过元注解限定了该注解的目标范围和作用时间

#### 3）注解类创建好了之后。我们该去使用这个注解了。

在使用这个注解之前，我们先思考一个问题。属性注解在使用的时候是需要通过反射获取属性实例并赋值的，我们在给View赋值的时候每次都需要做反射等操作。那么我们每次使用的时候都需要把这些代码重新写一遍么？答案肯定是NO，所以在这里我们将这个过程抽取出来。这里，我创建了一个InitBindView的类。在这个类中写了一个使用反射为view赋值的方法。下面我贴上代码。
```
public class InitBindView {


    public static void initBindView(Activity activity) {

        try {

            Class<Activity> clazz = (Class<Activity>) activity.getClass();//通过getClass拿到activity实例
            Field[] fields = clazz.getDeclaredFields();//通过反射拿到类内属性
            //循环取出属性
            for (Field field : fields) {
                if (field.isAnnotationPresent(BindView.class)) {//判断属性是否使用注解
                    BindView inject = field.getAnnotation(BindView.class);//如果使用就获得该类上注解
                    int id = inject.value();
                    if (0 != id) {
                        field.setAccessible(true);//提高反射速度
                        field.set(activity, activity.findViewById(id));//给被注解属性赋值
                    }
                }
            }

        } catch (Exception e) {
            //捕获异常后处理
        }

    }

}
```
通过注释我们可以了解到在这个方法中我们都做了哪些操作。简述一下就是通过反射拿到Activity中属性，判断是否使用了注解，如果使用，取出注解value并复制给view

#### 4）准备工作已经做好我们来开始使用这个注释吧。直接看代码。

```
public class MainActivity extends AppCompatActivity {


    @BindView(R.id.tv_annotation)
    private TextView tvAnnotation;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        InitBindView.initBindView(this);

        tvAnnotation.setText("Hello Annotation!!!");
    }
}
```
# Android是如何学习的

# sycronized关键字的类锁对象锁，如何保证线程安全？

# 重入锁跟sycronized关键字之间的区别

# 除了notify还有什么别的方式可以唤醒线程

# 说说你对Context的理解
![](https://img-blog.csdn.net/20131022221932765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXVhbnpleWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

# Listview的adapter是什么adapter，如何复用。

# RV是如何布局的

# 算法：如何从1T的无序数组(长度为n)里面找出前k大的数据，复杂度要求为O(logN)

**根据快速排序划分的思想 ：**

(1) 递归对所有数据分成[a,b）b（b,d]两个区间，(b,d]区间内的数都是大于[a,b)区间内的数 ； 

(2) 对(b,d]重复(1)操作，直到最右边的区间个数小于100个。

       注意[a,b)区间不用划分 ；因为[a,b)区间一定小于(b,d]区间；

(3) 返回上一个区间，并返回此区间的数字数目。

     如果个数大于100，对(b,d]重复(1)操作，直到最右边的区间个数小于100个；

     如果个数小于100，对上一区间的左边进行划分，分为[a2,b2）b2（b2,d2]两个区间，取（b2,d2]区间。

     如果个数超过100的就重复1操作，直到最后右边只有100个数为止。 时间复杂度为：O(N)

# 由A启动BActivity，A为栈内复用模式，B为标准模式，然后再次启动A或者杀死B，说说A，B的生命周期变化，为什么

a:OnCreate->OnStart->OnResume->OnPause
b:OnCreate->OnStart-OnResume
a:OnStop
b:OnPause
a:OnNewIntent->OnRestart->OnStart->OnResume
b:OnStop->OnDestroy

# 1.APP启动流程 

# 2.Webview内存泄露

我们在xml里面定义的WebView标签，**默认这个Activity就被这个webView作为Context参数所持有了**，因此，当这个Activity结束了想释掉放自己时，但是任然被webView所引用，因此GC回收不了，造成内存泄露

解决之道就是

1： 使用容器包裹WebView
```
<FrameLayout android:id="@+id/web_container" android:layout_width="fill_parent" android:layout_height="wrap_content"/>
```
2：手动创建WebView，使用ApplicationContext作为参数。在Ondestroy，调用容器的removeAllViews,同时调用webView的 destroy

```
public class TestActivity extends Activity { private FrameLayout mWebContainer; private WebView mWebView;

    @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState);

        setContentView(R.layout.your_layout);

        mWebContainer = (FrameLayout) findViewById(R.id.web_container);
        mWebView = new WebView(this);
        mWebContainer.addView(mWebView);
    }

    @Override protected void onDestroy() { super.onDestroy();
        mWebContainer.removeAllViews();
        mWebView.destroy();
    }
}

```

修改之后，反复测试，发现gc都能正常回收webView的资源了，非常好

最后给上android如何回避内存泄露的一些建议，大体的意思就是，内存不能被回收，很多情况下，都是因为Activity被某个元素持有引用导致GC无法回收的。

因此

1：保持activity持有对象的生命周期和activity是一致的。（特别是各种异步操作生命周期会比activity长）

2：使用Activity来代替全局对象Application，只有在你知道为啥使用Application长生命周期的时候，才去用它。

3：注意Activity的内部类会持有Activity的隐式引用（不然你咋能访问外部类的变量。。），因此使用static修饰内部类消除外部类隐式引用，并用weakReference访问外部类的属性。

# 3.组件间通信，如何传递对象 
# 4.Arouter原理 
# 5.如何取消一个网络请求 

OkHttp 取消请求
使用 Call.cancel() 可以立即停止掉一个正在执行的 call

异步请求时，可以在 OKHttp3.Callback 的回调方法里面有个参数是 Call 这个 call 可以单独取消相应的请求。

![](http://ou21vt4uz.bkt.clouddn.com/interview/http/okhttpCallCancel.png)

Volley网络框架发送请求后，页面退出时需要取消已经添加但没有完成的请求，否则可能导致内存泄露甚至Crash。
```
public void onDestroy() {
        MyVolley.cancelAll(TAG);
        super.onDestroy();
    }
```

# 6.两个activity之间来回切换的生命周期变化 
# 7.进程间如何通信，Binder机制
# 8.内存泄露及优化 
# 9.自定义view以及事件冲突 
# 10.线程池参数及定义，多线程是否一定会高效 
# 11.电量优化
# Webview的性能优化

# listview跟recyclerview之间的区别，然后上拉加载的时候分别应该如何处理

[Android RecyclerView上拉加载更多的实现和源码分析](https://blog.csdn.net/qq402164452/article/details/69374944)

上拉加载可以作为RecyclerView中的最后一个item， 这样上拉到底部的时候就会显示加载更多，然后再加一些判断逻辑来调用用户设置的监听回调接口 就可以实现上拉刷新功能

既然要实现一个可以上拉刷新的ListView,最简单的就是继承ListView:
1.通过addFooterView方法加载底部布局
2.通过removeFooterView移除布局
3.onScrollStateChanged:
if(最后一条可见item==最后一条item)&&(停止滑动)&&(!加载数据中)&&(!所有条目都可见){
addFooterView();
加载数据;
}
4.监听器OnLoadMoreListener:
if(数据加载完成){
removeFooterVeiw();
}

# 项目中用过哪些技术

# 同步普通方法跟static方法之间的区别

# 不用锁如何保证int自增安全

  java.util.concurrent.atomic 包中添加原子变量类。所有原子变量类都公开“比较并设置”原语，这些原语都是使用平台上可用的最快本机结构（比较并交换、加载链接/条件存储，最坏的情况下是旋转锁）来实现的。 java.util.concurrent.atomic  包中提供了原子变量的 9  种风格（AtomicInteger、AtomicLong、 olean、原子整型、长型、及原子标记引用和戳记引用类的数组形式， 其原子地更新一对值）。

     AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。

# 内存为什么会发生泄露

# 做过的性能优化，原理

# DVK跟JVM之间的区别

# 有没有diss过产品经理

# 平时看什么书

### JAVA进阶书籍：

[《Thinking in java》](http://union.click.jd.com/jdc?d=VUed84)
[《Effective Java》](http://union.click.jd.com/jdc?d=qj7efm)
深入理解JVM

### Android

[《App研发录》](http://item.jd.com/11791229.html)
[《Android群英传》](http://item.jd.com/11758334.html)
[《深入理解Android》](http://union.click.jd.com/jdc?d=OLlkvE)
[《Android开发艺术探索》](http://union.click.jd.com/jdc?d=xQb0ys)
[《Android系统源代码情景分析》](http://item.jd.com/11838754.html)

[《Android源码设计模式》](http://item.jd.com/11793928.html)，结合设计模式分析源码
[《Android框架揭秘》](http://item.jd.com/10002153064.html)，底层架构的一本好书

徐宜生推荐理由：底层书籍对于应用开发者来说，不用过于深入，主要用于学习设计思路和了解底层设计机制

[《Linux内核设计与实现》](http://union.click.jd.com/jdc?d=prBOg1)
[《深入理解Linux内核》](http://union.click.jd.com/jdc?d=jgOT1u)

## 其他
代码整洁之道
大话设计模式
重构
*   [程序员的是职业素养](https://book.douban.com/subject/11614538/)
*   [敏捷开发的艺术](https://book.douban.com/subject/4037534/)


# 为什么学python

# 项目中用到过哪些技术

# 期望在项目中扮演什么样的角色

# Sycronized原理

# ReentrantLock原理

# 静态内部类为什么能保证单例，JVM是如何实现的

# ART跟DVM做了哪些优化

# View是如何绘制到屏幕上的

# 写一个快排，有时间限制

二面面试官问地特别深，一上来就是各种原理 问了很多原理的原理，比如说Sycronized原理，View如何绘制到屏幕上去，这些对于我来说确实比较难，然后还问到了AQS, CAS的底层实现，答地一般般，我基本上对于JMM的了解就是类锁对象锁，指令重排序等

**三面：**

# GitHub上的开源项目是如何实现的

# 未来的职业规划

# 遇到问题如何解决

为什么没有自己搭建SS 三面是猎豹移动的产品总监，没有问技术上的问题，基本上如实回答就行了，没有那么多的套路，真诚即可。

**一面：**

# 深拷贝浅拷贝

# 输出一个集合{A,B,C,D}的全部子集

# 自定义View及注意事项

# 如何自动化部署打包发包流程

# JNI是否了解过

# 内存回收

# classloader

# 对热修复以及插件化了解多少

# 微信支付宝支付调用时上层是如何封装AIDL的

# 如何给一个app瘦身

基本上在之前的面试都有涉及到，依然是问我会的东西，一点点深入，第9道面试题我记得在掌阅面试的时候那个面试官说微信用地是广播，但是摩拜的面试官说微信用地是start ActivityForResult，这个我决定以后自己去深入研究下，看看他们到底是如何实现的，别的问题都是比较常见的。

**二面：**

# 如何实现一个推送，极光推送原理

# 说说Http协议，以及Tcp/Udp

# 常见的设计模式，如何实现一个观察者模式，如果需要有序通知观察者，该如何操作

# 实现一个图片加载框架应该考虑哪些

# 线程池有哪些参数，应该如何设计

# 性能优化是如何做的

# Java为什么要推出HashMap，它是如何解决hash冲突的

# JVM内存分配，编码时如何注意内存泄露

# Binder机制原理

摩拜问地都是很常见的问题，我能感觉到面试官在问我问题的时候并不在乎我对这个问题掌握地有多好，而是更加关注我对待某个知识点的态度，更多地赋予面试题一个场景，而不是空谈理论，是我比较喜欢的面试官。

**三面：**

# 为什么重复造轮子，自己去设计一些框架的原因

为了保证项目的稳定性同时能够更好地去定位问题

# 如何保证线上项目的稳定性

# 自己之前做的项目的规模
