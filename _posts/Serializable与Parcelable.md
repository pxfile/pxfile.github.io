Android 中Serializable与Parcelable
===


# 一、序列化、反序列化是什么？

## (1) 名词解释

对象的序列化 : 把[Java](http://www.2cto.com/kf/ware/Java/)对象转换为字节序列并存储至一个储存媒介的过程。
对象的反序列化:把字节序列恢复为Java对象的过程。

## (2) 序列化详细解释

对象的序列化涉及三个点关键点：Java对象、字节序列、存储。

1\. Java对象的组成？
Java对象包含变量与方法。但是序列与反序列化仅处理Java变量而不处理方法，序列与反序列化仅对数据进行处理。

2\. 什么是字符序列？
字符序列是两个词，字符是在计算机和电信领域中，字符（Character）是一个信息单位。数学上，序列是被排成一列的对象（或事件）。
《字符-维基百科》 ， 《序列-维基百科》 说白了就是连续排列的多个字符的集合。类似于1A165613246546

3\. 存储
字符序列需要保存到一个地方，可以是硬盘也可以是内存。
简单说法是：序列化把当前对象信息保存下来。反序列化刚好相反的操作。

# 二、Java对象与Java对象序列化的区别？

Java对象存在的前提必须在JVM运行期间存在，如果想在JVM非运行的情况下或者在其他机器JVM上获取指定Java对象，在现有Java对象的机制下都不可能完成。
与Java对象不同的是，如果对Java对象执行序列化操作，因为原理是把Java对象信息保存到存储媒介，所以可以在以上Java对象不可能存在的两种情况下依然可以使用Java对象。

# 三、为什么要使用序列化、反序列化？

根据以上对序列化、反序列化的理解，这个疑问可以翻译成，为什么需要把对象信息保存到存储媒介中并之后读取出来？
因为二中的解释，开发中有在JVM非运行的情况下或者在其他机器JVM上获取指定Java对象的需求。

# 四、[Android](http://www.2cto.com/kf/yidong/Android/) 中Serializable与Parcelable区别？

两种都是用于支持序列化、反序列化话操作，**两者最大的区别在于存储媒介的不同，Serializable使用IO读写存储在硬盘上，而Parcelable是直接在内存中读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable**。

两者区别在于存储媒介的不同。

Serializable使用IO读写存储在硬盘上。序列化过程使用了反射技术，并且期间产生临时对象。优点代码少。

Parcelable是直接在内存中读写，我们知道内存的读写速度肯定优于硬盘读写速度，所以Parcelable序列化方式性能上要优于Serializable方式很多。但是代码写起来相比Serializable方式麻烦一些。

通过比较发现，性能与简便我们只能选其一，大多数情况下使用Serializable也是没什么问题的，但是还是建议大家使用Parcelable方式实现序列化，毕竟性能好很多，其实也没多麻烦。
