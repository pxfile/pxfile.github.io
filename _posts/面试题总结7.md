面试题总结7
===


# dp是什么，sp呢，有什么区别
[px、dp和sp，这些单位有什么区别？](http://www.cnblogs.com/bjzhanghao/archive/2012/11/06/2757300.html)

**db像素密度**。假设有一部手机，屏幕的物理尺寸为1.5英寸x2英寸，屏幕分辨率为240x320，则我们可以计算出在这部手机的屏幕上，每英寸包含的像素点的数量为240/1.5=160dpi（横向）或320/2=160dpi（纵向），160dpi就是这部手机的像素密度，像素密度的单位dpi是Dots Per Inch的缩写，即每英寸像素数量。横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。

**sp**和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp>1dp=0.00625英寸。

**最佳实践：**

文字的尺寸一律用sp单位，非文字的尺寸一律使用dp单位。例如textSize="16sp"、layout_width="60dp"；偶尔需要使用px单位，例如需要在屏幕上画一条细的分隔线时：
`
<View layout_width="match_parent"layout_height="1px"/>
`

最后，推荐一张Android UI设计参考图：[Android Design Cheat Sheet](http://www.doubleencore.com/wp-content/uploads/2014/01/Android-Design-Cheat-Sheet-highres.png)

# 自定义View，ViewGroup注意那些回调

* View的绘制：onMeasure,onLayout,onDraw

* 事件传递机制：dispatchTouchEvent,onTouchEvent,onIntercepteTouchEvent

# 界面卡顿的原因以及解决方法

Android应用启动慢，使用时经常卡顿，是非常影响用户体验的，应该尽量避免出现。卡顿的场景有很多，按场景分为4类：UI绘制，应用启动，页面跳转，事件响应，如图：
![卡顿优化](http://ou21vt4uz.bkt.clouddn.com/performance_optimizationperformance_optimization2.png)

* **界面绘制** 主要原因是绘制的层级深，页面复杂，刷新不合理，由于这些原因导致卡顿的场景更多出现在UI和启动后的初始界面以及跳转到页面的绘制上。

* **数据处理** 导致卡顿的原因是数据处理量太大，一般分为三种情况，一是数据处理在UI线程，二是数据处理占用CPU高，导致主线程拿不到时间片，三是内存增加导致GC频繁，从而引起卡顿。

引起卡顿的原因很多，归根结底是显示有问题，所以要解决卡顿问题，就要了解Android系统的显示原理。

### Android系统显示原理

Android显示过程可以简单的概括为：Android应用程序把经过测量，布局，绘制后的surface缓存数据，通过SurfaceFlingger把数据渲染到显示屏幕上，通过Android刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信吧应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕上。

我们知道Android的每个View绘制中有三个核心步骤：Measure，Layout，Draw。具体实现是从ViewRootImp类的performTraversals（）方法开始执行，Measure和layout都是通过递归来获取View的大小和位置，并且以深度作为优先级，可以看出层级越深，元素越多，耗时也越长。

真正把需要显示的数据渲染到屏幕上，是通过系统级进程中的 SurfaceFlinger 服务来实现的，那么这个SurfaceFlinger 服务主要做了哪些工作呢？如下：

*   响应客户端事件，创建 Layer 与客户端的 Surface 建立连接。

*   接收客户端数据及属性，修改 Layer 属性，如尺寸、颜色、透明度等。

*   将创建的 Layer 内容刷新到屏幕上。

*   维持 Layer 的序列，并对 Layer 最终输出做出裁剪计算。

既然是两个不同的进程，那么肯定是需要一个跨进程的通信机制来实现数据传递，在 Android 显示系统中，使用了 Android 的匿名共享内存：SharedClient，每一个应用和 SurfaceFlinger 之间都会创建一个SharedClient ，然后在每个 SharedClient 中，最多可以创建 31 个 SharedBufferStack，每个 Surface 都对应一个 SharedBufferStack，也就是一个 Window。

一个 SharedClient 对应一个Android 应用程序，而一个 Android 应用程序可能包含多个窗口，即 Surface 。也就是说 SharedClient 包含的是 SharedBufferStack的集合，其中在显示刷新机制中用到了双缓冲和三重缓冲技术。最后总结起来显示整体流程分为三个模块：应用层绘制到缓存区，SurfaceFlinger 把缓存区数据渲染到屏幕，由于是不同的进程，所以使用 Android 的匿名共享内存 SharedClient 缓存需要显示的数据来达到目的。

除此之外，我们还需要一个名词：FPS。FPS 表示每秒传递的帧数。在理想情况下，60 FPS 就感觉不到卡，这意味着每个绘制时长应该在16 ms 以内。但是 Android 系统很有可能无法及时完成那些复杂的页面渲染操作。Android 系统每隔 16ms 发出 VSYNC 信号，触发对 UI 进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的 60FPS。如果某个操作花费的时间是 24ms ，系统在得到 VSYNC 信号时就无法正常进行正常渲染，这样就发生了丢帧现象。那么用户在 32ms 内看到的会是同一帧画面，这种现象在执行动画或滑动列表比较常见，还有可能是你的 Layout 太过复杂，层叠太多的绘制单元，无法在 16ms 完成渲染，最终引起刷新不及时。

### 卡顿根本原因

根据Android系统显示原理可以看到，影响绘制的根本原因有一下两方面：
* 绘制任务太重，绘制一帧内容耗时太长

* 主线程太忙，根据系统传递过来的VSYNC信号来时还没准备好数据导致丢帧

绘制耗时太长，有一些工具可以帮助我们定位问题。主线程太忙则需要注意了，主线程关键职责是处理用户交互，在屏幕上绘制像素，并进行加载显示相关的数据，所以特别需要避免任何主线程的事情，这样应用程序才能保持对用户操作的即时响应。总结起来，主线程主要做一下几方面工作：

* UI生命周期控制

* 系统事件处理

* 消息处理

* 界面布局

* 界面绘制

* 界面刷新

除此之外，应该尽量避免将其他处理放在主线程中，特别是复杂的数据计算和网络请求等。

### 性能分析工具

性能问题并不容易复现，也不好定位，但是真的碰到问题还是需要去解决的，那么分析问题和确认问题是否解决，就需要借助相应的的调试工具，比如查看 Layout 层次的 Hierarchy View、Android 系统上带的 GPU Profile 工具和静态代码检查工具 Lint 等，这些工具对性能优化起到非常重要的作用，所以要熟悉，知道在什么场景用什么工具来分析。

1，Profile GPU Rendering

在手机开发者模式下，有一个卡顿检测工具叫做：Profile GPU Rendering，如图：
![]()

它的功能特点如下：
* 一个图形监测工具，能实时反应当前绘制的耗时

* 横轴表示时间，纵轴表示每一帧的耗时

* 随着时间推移，从左到右的刷新呈现

* 提供一个标准的耗时，如果高于标准耗时，就表示当前这一帧丢失

2，TraceView

TraceView 是 Android SDK 自带的工具，用来分析函数调用过程，可以对 Android 的应用程序以及 Framework 层的代码进行性能分析。它是一个图形化的工具，最终会产生一个图表，用于对性能分析进行说明，可以分析到每一个方法的执行时间，其中可以统计出该方法调用次数和递归次数，实际时长等参数维度，使用非常直观，分析性能非常方便。

3，Systrace UI 性能分析

Systrace 是 Android 4.1及以上版本提供的性能数据采样和分析工具，它是通过系统的角度来返回一些信息。它可以帮助开发者收集 Android 关键子系统，如 surfaceflinger、WindowManagerService 等 Framework 部分关键模块、服务、View系统等运行信息，从而帮助开发者更直观地分析系统瓶颈，改进性能。Systrace 的功能包括跟踪系统的 I/O 操作、内核工作队列、CPU 负载等，在 UI 显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上。

### 优化建议

1，布局优化

布局是否合理主要影响的是页面测量时间的多少，我们知道一个页面的显示测量和绘制过程都是通过递归来完成的，多叉树遍历的时间与树的高度h有关，其时间复杂度 O(h)，如果层级太深，每增加一层则会增加更多的页面显示时间，所以布局的合理性就显得很重要。

那布局优化有哪些方法呢，主要通过减少层级、减少测量和绘制时间、提高复用性三个方面入手。总结如下：

* **减少层级** 合理使用RelativeLayout和LinerLayout，合理使用Merge

* **提高显示速度**  使用 ViewStub，它是一个看不见的、不占布局位置、占用资源非常小的视图对象。

* **布局复用** 可以通过<include>标签提高复用

* **尽可能少使用wrap_content** wrap_content会增加布局Measure时的计算成本，在一直宽高为固定值时，不用wrap_content。

* **删除控件中无用的属性**

2，避免过度绘制

过度绘制是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构中，如果不可见的 UI 也在做绘制的操作，就会导致某些像素区域被绘制了多次，从而浪费了多余的 CPU 以及 GPU 资源。

如何避免过度绘制呢，如下：

*  **布局上的优化** 移除 XML 中非必须的背景，移除 Window 默认的背景、按需显示占位背景图片

*  **自定义View优化** 使用 canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。

3，启动优化

通过对启动速度的监控，发现影响启动速度的问题所在，优化启动逻辑，提高应用的启动速度。启动速度主要完成三件事：UI布局，绘制和数据准备，因此启动速度优化就是需要优化这样三个过程：

* **UI布局** 应用一般都是有闪屏页，优化闪屏页的UI布局，可以通过Profile GPU Rendering检测丢帧情况

* **启动加载逻辑优化** 可以采用分布加载，异步加载，延期加载策略来提高应用启动速度

* **数据准备** 数据初始化分析，加载数据可以考虑用线程初始化等策略

4，合理的刷新机制

在应用开发过程中，因为数据的变化，需要刷新页面来展示新的数据，但频繁刷新会增加资源开销，并且可能导致卡顿发生，因此，需要一个合理的刷新机制来提高整体的 UI 流畅度。合理的刷新需要注意以下几点：

* **尽量减少刷新次数**

* **尽量避免后台有高的CPU线程运行**

* **缩小刷新区域**

5，其他

在实现动画效果时，需要根据不同场景选择合适的动画框架来实现。有些情况下，可以用硬件加速方式来提供流畅度。

# android中的存储类型

* 网络

* 文件

* sharepreference

* 数据库

* 内存

# service用过么，基本调用方法

## 一个started服务

context.startService context.stopService

onCreate()->onStartCommand()->onDestory

　　这类服务由其它组件调用startService()来创建。然后保持运行，且必须通过调用stopSelf()自行终止。其它组件也可通过调用stopService() 终止这类服务。服务终止后，系统会把它销毁。

　　如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且系统只会创建Service的一个实例（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。

## 　一个bound服务

context.bindService() context.unBindService()

onCreate()->onBind()->onUnBind()->onDestory()

　　服务由其它组件（客户端）调用bindService()来创建。然后客户端通过一个IBinder接口与服务进行通信。客户端可以通过调用unbindService()来关闭联接。多个客户端可以绑定到同一个服务上，当所有的客户端都解除绑定后，系统会销毁服务。（服务不需要自行终止。）

　　如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService 调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。

# Handler机制

# LinearLayout、FrameLayout、RelativeLayout性能对比，为什么

[如何优化你的布局层级结构之RelativeLayout和LinearLayout及FrameLayout性能分析](https://blog.csdn.net/hejjunlin/article/details/51159419)

LinearLayout<FrameLayout<RelativeLayout

* 1.RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure

* 2.RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。

* 3.在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。
最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。

* 4.能用两层LinearLayout，尽量用一个RelativeLayout，在时间上此时RelativeLayout耗时更小。另外LinearLayout慎用layout_weight,也将会增加一倍耗时操作。由于使用LinearLayout的layout_weight,大多数时间是不一样的，这会降低测量的速度。这只是一个如何合理使用Layout的案例，必要的时候，你要小心考虑是否用layout_weight。总之减少层级结构，才是王道，让onMeasure做延迟加载，用viewStub，include等一些技巧。

#  Activity的生命周期，finish调用后其他生命周期还会走么？

[调用Activity.finish()方法后的生命周期执行过程](https://www.jianshu.com/p/ede291c83e70)

#   FW层熟悉么，源码看过么

#   GC回收机制熟悉么，分代算法知道么

## 什么对象可以被回收
* 引用计数(相互引用永远存在不会被回收)

* 什么对象可以被回收
可达性分析
GCRoot到对象是否可达，不可达的对象没有引用，可被回收

## 回收算法

* 复制算法

* 标记整理

* 标记删除

* 分代回收（年轻代（复制算法）老年代（标记整理或标记删除）永久代（标记整理或标记删除））

# Java的类类加载原理

Person p=new Person()

* 1.通过编译器将person的class编译成.class文件，将class文件加载到虚拟机中

* 2.如果person中存在static代码块就加载静态代码块

* 3.建立person中属性，赋予默认初始化

* 4.给属性赋予显示初始化

* 5.执行构造代码块

* 6.执行构造函数

* 7.将内存中的p的地址赋值给p变量

#  内存泄漏如何排查，MAT分析方法以及原理，各种泄漏的原因是什么比如

## 内存检测工具
使用工具memory monitor等查看
[Android内存泄露自动检测神器LeakCanary](https://blog.csdn.net/liuhongwei123888/article/details/50454871)

## 内存泄漏的原因

* 资源访问没有及时关闭，cursor，文件流等

* 注册的对象没有及时注销，register broadcast

* Context没有使用正确，单例中使用Activity的Context等

* 非静态内部类

* handler的使用

* webview的使用没有及时销毁

* 容器对象没有及时清除

* 大量静态对象

#   Handler为什么会泄漏

handler如果持有Activity的Context，当Activity关闭时，handler没有及时remove所有的callback或者message，Activity的对象还在被引用，就不能被销毁，导致内存泄漏。

#   gradle熟悉么，自动打包知道么
[美团Android自动化之旅—生成渠道包](https://tech.meituan.com/mt-apk-packaging.html)

[美团Android自动化之旅—适配渠道包](https://tech.meituan.com/mt-apk-adaptation.html)

#   介绍下先的app架构和通信

#   自己负责过哪些模块，跟同事相比自己的优势是什么

#   遇到过什么印象深刻的问题，怎么解决的

# 减少APK包的大小

## 代码

* 保持良好的编程习惯，不要重复或者不用的代码，谨慎添加libs，移除使用不到的libs。

* 使用proguard混淆代码，它会对不用的代码做优化，并且混淆后也能够减少安装包的大小。

* native code的部分，大多数情况下只需要支持armabi与x86的架构即可。如果非必须，可以考虑拿掉x86的部分。

## 资源

* 使用Lint工具查找没有使用到的资源。去除不使用的图片，String，XML等等。

* assets目录下的资源请确保没有用不上的文件。

* 生成APK的时候，aapt工具本身会对png做优化，但是在此之前还可以使用其他工具如tinypng对图片进行进一步的压缩预处理。

* jpeg还是png，根据需要做选择，在某些时候jpeg可以减少图片的体积。

* 对于9.png的图片，可拉伸区域尽量切小，另外可以通过使用9.png拉伸达到大图效果的时候尽量不要使用整张大图。

## 策略

* 有选择性的提供hdpi，xhdpi，xxhdpi的图片资源。建议优先提供xhdpi的图片，对于mdpi，ldpi与xxxhdpi根据需要提供有差异的部分即可。

* 尽可能的重用已有的图片资源。例如对称的图片，只需要提供一张，另外一张图片可以通过代码旋转的方式实现。

* 能用代码绘制实现的功能，尽量不要使用大量的图片。例如减少使用多张图片组成animate-list的AnimationDrawable，这种方式提供了多张图片很占空间。



