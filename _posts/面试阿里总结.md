# 一面

## android中的dp、px、dip相关概念
### px 像素
构成图像的最小单位，1px代表屏幕上的一个物理的像素点。但px单位不被建议使用。因为同样像素大小的图片在不同手机显示的实际大小可能不同

###  dp/dip 

#### dpi

dpi全称是dots per inch，对角线每英寸的像素点的个数，分辨率越高，dpi越高。分辨率相同，屏幕对角线英寸数越小，dpi越高。

#### dp/dip

dp也叫dip，是device independent pixels。设备不依赖像素的一个单位。在不同的像素密度的设备上会自动适配，比如: 
在320x480分辨率，像素密度为160,1dp=1px 
在480x800分辨率，像素密度为240,1dp=1.5px 
计算公式：px = dp * (dpi/160)

**使用px作为单位的，在不同的设备中会显示不同的效果。使用dp作为单位的，会根据不同的设备进行转化，适配不同机型。**

### sp

sp ：Scale-Independent Pixels,**会随着系统的字体大小改变**，常用于设置字体大小。**建议在字体大小的数值要使用sp作为单位**，尽量避免使用奇数或小数，因为容易造成精度的丢失

## handler机制，四个组成部分及源码解析

## 布局相关的控件作用及实现原理

### LinearLayout (线性布局)

流式布局有个特点，就是下一个控件的坐标原点由上一个控件来决定，你可以沿水平方向或者垂直方向上来排列你的控件

### RelativeLayout (相对布局)

相对布局的本质就是以不变应万变。也就是说相对布局可以根据已经固定的控件来确定其他新加控件的位置。

### 帧布局 (FrameLayout)

所有放在布局里的控件，都按照层次堆叠在屏幕的左上角。后加进来的控件覆盖前面的控件。

### 表格布局（TableLayout）

通过画表表格的方式来实现布局。 在表格布局中，整个页面就相当于一张大的表格，控件就放在每个Cell中

## android中的布局优化

relativelayout和LinearLayout在实现效果同等情况下选择使用哪个？为什么？

## view的工作原理及measure、layout、draw流程，要求了解源码

## 怎样自定义一个弹幕控件？

### 控件
使用RecyclerView空间
LayoutManager.setStackFromEnd(true);//列表再底部开始展示，反转后由上面开始展示

### 拉取弹幕
获取弹幕消息成功后，先去重然后存放在**积压队列**，是个list。接着又通过handler发消息去拉取弹幕，是一个一直反复循环的过程。

### 显示弹幕
同步**积压队列**中的弹幕到**显示队列**中

**整个过程都是加锁的 synchronized**
1.弹幕都是一条一条添加的，显的比较自然
2.判断最后一条可见的index是否是在最后，是的话，添加完弹幕后还有滑到最后的index，就不会让用户在看的时候有突然滑动的奇怪现象。
3.添加一条成功后，局部刷新
4.每次同步完所有的弹幕后，将**积压队列**中相应的这些弹幕都remove掉，以防重复显示，还有就是队列过大造成的OOM

## 如果控件内部卡顿你如何去解决并优化？

### 原因
* **界面绘制** 主要原因是绘制的层级深，页面复杂，刷新不合理，由于这些原因导致卡顿的场景更多出现在UI和启动后的初始界面以及跳转到页面的绘制上。

* **数据处理** 导致卡顿的原因是数据处理量太大，一般分为三种情况，一是数据处理在UI线程，二是数据处理占用CPU高，导致主线程拿不到时间片，三是内存增加导致GC频繁，从而引起卡顿。

### 性能分析工具

1.Profile GPU Rendering
2.TraceView

### 布局优化建议

#### 布局优化
* **减少层级** 合理使用RelativeLayout和LinerLayout，合理使用Merge

* **提高显示速度**  使用 ViewStub，它是一个看不见的、不占布局位置、占用资源非常小的视图对象。

* **布局复用** 可以通过<include>标签提高复用

* **尽可能少使用wrap_content** wrap_content会增加布局Measure时的计算成本，在一直宽高为固定值时，不用wrap_content。

* **删除控件中无用的属性**

#### 避免过度绘制
* **布局上的优化** 移除 XML 中非必须的背景，移除 Window 默认的背景、按需显示占位背景图片

* **自定义View优化** 使用 canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。

### 内存分析工具

 1，Memory Monitor
 2，Heap Viewer
 3，LeakCanary
[LeakCanary](https://link.juejin.im/?target=https%3A%2F%2Fcorner.squareup.com%2F2015%2F05%2Fleak-canary.html) 函数库也是一个很好的工具，它可以追踪对象并确保它们不会泄漏。如果内存泄露了 —— 你将收到一个通知告诉你在哪里发生了什么。

### 内存优化建议

* **常见内存泄漏的场景**

* **节制使用Service**
建议使用IntentService，它会在处理完交代给它的任务之后尽快结束自己

* **避免使用枚举**

* **使用优化集合sparseArray**

* **避免内存抖动**
避免在循环中创建临时对象；
避免在onDraw中创建Paint、Bitmap对象等

## listview的缓存机制

### listview
**RecycleBin缓存机制**
`mActiveViews` : 缓存屏幕上可见的view 

`mScrapViews` : ListView中所有的废弃缓存

ListView每当一项子view滑出界面时，RecycleBin会调用addScrapView()方法将这个废弃的子view进行缓存。每当子view滑入界面时，RecycleBin会调用getScrapView()方法获取一个废弃已缓存的view

convertView就是RecycleBin缓存机制调用getScrapView()方法获取废弃已缓存的view。`getView()`方法中有个判断，`if (convertView == null)`，当convertView为空，也就是没有废弃已缓存的view时，将调用LayoutInflater的inflate()方法加载出来布局view，这个操作是比较耗时的；当convertView不为空时，我们就直接用convertView了，而不需要再次调用LayoutInflater的inflate()方法加载出来布局view。

我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。

### RecyclerView回收机制

RecyclerView和ListView的回收机制非常相似，但是ListView是以View作为单位进行回收，RecyclerView是以ViewHolder作为单位进行回收。Recycler是RecyclerView回收机制的实现类，他实现了四级缓存：

*   mAttachedScrap: 缓存在屏幕上的ViewHolder。

*   mCachedViews: 缓存屏幕外的ViewHolder，默认为2个。ListView对于屏幕外的缓存都会调用`getView()`。

*   mViewCacheExtensions: 需要用户定制，默认不实现。

*   mRecyclerPool: 缓存池，多个RecyclerView共用。

ListView和RecyclerView缓存机制基本一致：

1). mActiveViews和mAttachedScrap功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindView；

2). mScrapView和mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用.

3). RecyclerView的优势在于a.mCacheViews的使用，可以做到屏幕外的列表项ItemView进入屏幕内时也无须bindView快速重用；b.mRecyclerPool可以供多个RecyclerView共同使用，在特定场景下，如viewpaper+多个列表页下有优势.客观来说，RecyclerView在特定场景下对ListView的缓存机制做了补强和完善。

* 从mAttachedScrap中通过匹配id获取holder缓存

* 从mCachedViews中通过匹配id获取holder缓存。 

* 从ViewCacheExtension获取holder缓存。 

* 通过RecyclerView 的ViewHolder缓存池获取holder。

## Invalidate、postInvalidate、requestLayout应用场景

### requestLayout

当我们动态移动一个View的位置，或者View的大小、形状发生了变化的时候，我们可以在view中调用这个方法，即：

```java
view.requestLayout();
```
如果子View调用了这个方法，其实会从View树重新进行一次测量、布局、绘制这三个流程，最终就会显示子View的最终情况。

* 从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发生的时候再执行。

* 在requestLayout方法中，首先先判断当前View树是否正在布局流程，接着为当前子View设置标记位，该标记位的作用就是标记了当前的View是需要进行重新布局的，

* 接着调用mParent.requestLayout方法，这个十分重要，因为这里是向父容器请求布局，即调用父容器的requestLayout方法，为父容器添加PFLAG_FORCE_LAYOUT标记位，而父容器又会调用它的父容器的requestLayout方法，

* 即requestLayout事件层层向上传递，直到DecorView，即根View，而根View又会传递给ViewRootImpl，也即是说子View的requestLayout事件，最终会被ViewRootImpl接收并得到处理。

* 纵观这个向上传递的流程，其实是采用了责任链模式，即不断向上传递该事件，直到找到能处理该事件的上级，在这里，只有ViewRootImpl能够处理requestLayout事件。

**小结**：子View调用requestLayout方法，会标记当前View及父容器，同时逐层向上提交，直到ViewRootImpl处理该事件，ViewRootImpl会调用三大流程，从measure开始，对于每一个含有标记位的view及其子View都会进行测量、布局、绘制。

### invalidate

该方法的调用会引起View树的重绘，常用于内部调用(比如 setVisiblity())或者需要刷新界面的时候,需要在主线程(即UI线程)中调用该方法。

invalidate有多个重载方法，但最终都会调用invalidateInternal方法，在这个方法内部，进行了一系列的判断，判断View是否需要重绘，接着为该View设置标记位，然后把需要重绘的区域传递给父容器，即调用父容器的invalidateChild方法。

**小结**：当子View调用了invalidate方法后，会为该View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递到ViewRootImpl中，最终触发performTraversals方法，进行开始View树重绘流程(只绘制需要重绘的视图)。

### postInvalidate

这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。

用了Handler，发送了一个异步消息到主线程，显然这里发送的是MSG_INVALIDATE，即通知主线程刷新视图，参数message传递过来的正是View视图的实例，然后直接调用了invalidate方法，然后继续invalidate流程。

## 多线程，5个线程内部打印hello和word，hello在前，要求提供一种方法使得5个线程先全部打印出hello后再打印5个word。

字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。

　　CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：
```
public CyclicBarrier(int parties, Runnable barrierAction) {
}
 
public CyclicBarrier(int parties) {
}
```

　　参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。

　　然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：

```
public int await() throws InterruptedException, BrokenBarrierException { };
public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException { };
```

 　　第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；

　　第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。

```
public class Test {
    public static void main(String[] args) {
        int N = 5;
        CyclicBarrier barrier  = new CyclicBarrier(N);
        for(int i=0;i<N;i++)
            new Writer(barrier).start();
    }
    static class Writer extends Thread{
        private CyclicBarrier cyclicBarrier;
        public Writer(CyclicBarrier cyclicBarrier) {
            this.cyclicBarrier = cyclicBarrier;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(1000);      //以睡眠来模拟写入数据操作
                System.out.println("线程"+Thread.currentThread().getName()+"say: hello");
                cyclicBarrier.await();
System.out.println("线程"+Thread.currentThread().getName()+"say: world");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }catch(BrokenBarrierException e){
                e.printStackTrace();
            }
        }
    }
}
```

## 实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - - - view的高度可自适应拓展

* **MeasureSpec.EXACTLY**：精确模式, eg:100dp,match_parent. (注：为什么match_parent属于精确模式呢？这是因为我们手机屏幕的大小是确定的，即使你已经先制定了一个控件比如TextView的高为50dp，下面又设置了一个View的高为match_parent，那实际上 该View的高=屏幕的高（确定的）-TextView的高（也是确定的） 确定的值 减去 确定的值 结果还是确定的 )
 
* **MeasureSpec.AT_MOST**： 至多模式, view最多可以获得的宽高值,它需要计算所有包含的子view的宽高，最后计算出来的宽高总和值,eg:wrap_content.

* **UNSPECIFIED**:未指定模式,想设置多宽多高,就给你多宽多高,一般的控件不会指定这种模式,但也存在，eg:scrollview的宽高测量，就是使用的此种模式

**②那么在我们的流式布局内，应该怎么设置布局的宽高呢?** **onMeasure()：**

* 1:如果布局指定的宽是match_parent或者精确的宽度值，那么直接就可以从父控件传入的测量规格中直接获取布局宽度，高度同理.
 
* 2:如果布局指定的宽高不是EXACTLY,而是AT_MOST,那么这时候，就需要计算每一个子view的宽高，来决定布局的宽高了。
 
* **宽度:摆放的所有子view占据宽度最多的一行,作为布局宽度。** 
* **高度:摆放的所有子view总共占据几行的高度总和。**

**③实现子View的布局方式： onLayout()**

* 使用onLayout():设置ViewGroup内包含的所有子view的位置;
 
* 获取到每一行的每一个子view,计算出它的left,top,right,bottom,调用layout方法设置其在流式布局当中的位置。
 
* 宽度=子view最多的那行的宽度=那一行每一个子view的宽度+leftMargin+rightMargin;
 
* 高度=所有行的高度 = 每一行的高度+topMargin+bottomMargin;
 
* 使用 setMeasureDimension()—>设置流式布局的宽高。

### 简单分析
1、对于FlowLayout，需要指定的LayoutParams，我们目前只需要能够识别margin即可，即使用系统的MarginLayoutParams.

2、onMeasure中计算所有childView的宽和高，然后根据childView的宽和高，计算自己的宽和高。（当然，如果不是wrap_content，直接使用父ViewGroup传入的计算值即可）

3、onLayout中对所有的childView进行布局

### onMeasure

首先得到其父容器传入的测量模式和宽高的计算值，然后遍历所有的childView，使用measureChild方法对所有的childView进行测量。然后根据所有childView的测量得出的宽和高得到该ViewGroup如果设置为wrap_content时的宽和高。最后根据模式，如果是MeasureSpec.EXACTLY则直接使用父ViewGroup传入的宽和高，否则设置为自己计算的宽和高。

* 父控件传进来的宽度和高度以及对应的测量模式

* 如果当前ViewGroup的宽高为wrap_content的情况，记录宽高，

* 循环测量子View的宽和高，获得子View占据的宽度，子View占据的高度，如果加入当前child，则超出最大宽度，则的到目前最大宽度给width，类加height 然后开启新行。叠加当前高度，开启记录下一行的高度。否则累加值lineWidth,lineHeight取最大高度

* 如果是最后一个，则将当前记录的最大宽度和当前lineWidth做比较

### onLayout
onLayout中完成对所有childView的位置以及大小的指定

* 遍历所有的childView，用于设置allViews的值，以及mLineHeight的值。

* 根据allViews的长度，遍历所有的行数

* 遍历每一行的中所有的childView，对childView的left , top , right , bottom 进行计算，和定位

* 重置left和top，准备计算下一行的childView的位置


## 编程题：将元素均为0、1、2的数组排序。在手打了一种直接遍历三种数目并打印的方法后让手写实现，手写实现后让再说一种稳定的方法，说了一种通过三个下标遍历一遍实现的方法，读者可自行百度，在此不赘述。

### 解法一：

1.  遍历数组，统计红、白、蓝（0，1，2）三种元素的个数
2.  根据三种颜色元素的个数重排数组

这种算法利用了[计数排序](https://link.jianshu.com?t=http://www.cnblogs.com/eniac12/p/5332117.html#s1)的思想，时间复杂度O(n)，代码如下

```
public class Solution {
    public void sortColors(int[] nums) {
        int red = 0;
        int white = 0;
        int blue = 0;
        for (int i = 0; i < nums.length; i++) {
            switch (nums[i]) {
                case 0:
                    red++;
                    break;
                case 1:
                    white++;
                    break;
                case 2:
                    blue++;
                    break;
                default:
                    break;
            }
        }
        for (int i = 0; i < nums.length; i++) {
            if (i < red) {
                nums[i] = 0;
            } else if (i < red + white) {
                nums[i] = 1;
            } else {
                nums[i] = 2;
            }
        }
    }
}
```
### 解法二：

利用[快速排序](https://link.jianshu.com/?t=http://www.cnblogs.com/eniac12/p/5329396.html#s6)partition过程的思想，我们可以把数组分成三部分，前部（全部是0），中部（全部是1）和后部（全部是2），每一个元素必属于其中之一。当我们把前部和后部各排在数组的前边和后边，中部自然就排好了。

设置两个指针begin和end，begin指向前部末尾的下一个元素（刚开始默认前部无0，所以begin指向第一个位置），end指向后部开头的前一个位置（刚开始默认后部无2，所以end指向最后一个位置），然后设置一个遍历指针current，从头开始进行遍历。

1.  若遍历到的位置为1，则说明它一定属于中部，中部的我们都不动，然后current继续向后移动一个位置。

2.  若遍历到的位置为0，则说明它一定属于前部，于是就和begin位置进行交换，然后begin向后移动一个位置。由于从begin位置交换过来的元素一定是已经遍历过的元素，所以**current也向后移动一个位置**。

3.  若遍历到的位置为2，则说明它一定属于后部，于是就和end位置进行交换，然后end向前移动一个位置。由于从end位置交换过来的元素我们并没有遍历过，它可能是属于前部的，所以**此时current并不向后移动**。

上述过程的代码如下，时间复杂度也为O(n)

```
public class Solution {
    public void sortColors(int[] nums) {
        int begin = 0;
        int end = nums.length - 1;
        int cur = 0;
        while (cur <= end) {
            if (nums[cur] < 1) {
                swapElement(nums, begin, cur);
                begin++;
                cur++;  // 从begin位置交换过来的元素一定是已经遍历过的元素
            } else if (nums[cur] > 1) {
                swapElement(nums, end, cur);
                end--;
                // 从end位置交换过来的元素我们并没有遍历过
            } else {
                cur++;
            }
        }
    }

    public void swapElement(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
# 二面

## JVM方面

java内存模型，五个部分，程序计数器、栈、本地栈、堆、方法区。

每个部分的概念、特点、作用。


### JAVA 内存模型

由于Java程序是交由JVM执行的，所以我们在谈Java内存区域划分的时候事实上是指JVM内存区域划分。在讨论JVM内存区域划分之前，先来看一下Java程序具体执行的过程：

![](https://troywu0.gitbooks.io/spark/content/assets/javaMemoryModel1.jpg)

如上图所示，首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。**在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区）**，也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

#### 运行时数据区包括哪几部分？
程序计数器、Java栈、本地方法栈、堆、方法区

##### **程序计数器**

用来指示 执行哪条指令的

由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，**程序计数器是每个线程所私有的**。

在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。

由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。

##### **Java栈**
Java栈也称作虚拟机栈（Java Vitual Machine Stack），也就是我们常常所说的栈，。事实上，Java栈是Java方法执行的内存模型。

* Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括**局部变量表**(Local Variables)、**操作数栈**(Operand Stack)、**指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用**(Reference to runtime constant pool)、**方法返回地址**(Return Address)和**一些额外的附加信息**。

当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。

讲到这里，大家就应该会明白为什么 在 使用 递归方法的时候容易导致栈内存溢出的现象了以及为什么栈区的空间不用程序员去管理了（当然在Java中，程序员基本不用关系到内存分配和释放的事情，因为Java有自己的垃圾回收机制），这部分空间的分配和释放都是由系统自动实施的。对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。下图表示了一个Java栈的模型：

![](https://troywu0.gitbooks.io/spark/content/assets/javaStack.jpg)

**局部变量表**，顾名思义，想必不用解释大家应该明白它的作用了吧。就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。

**操作数栈**，想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。

**指向运行时常量池的引用**，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。

**方法返回地址**，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。

由于每个线程正在执行的方法可能不同，因此**每个线程都会有一个自己的Java栈，互不干扰**。

##### **本地方法栈**

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方方法的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

##### **堆**

java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作

##### **方法区**

方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

在方法区中有一个非常重要的部分就是**运行时常量池**，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“**永久代**”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。


### 类加载的过程，加载、验证、准备、解析、初始化。每个部分详细描述。

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示：

![](https://img-blog.csdn.net/20140105211344671)

其中类加载的过程包括了**加载、验证、准备、解析、初始化**五个阶段。

在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。

另外注意这里的几个阶段是按顺序**开始**，而不是按顺序**进行**或**完成**，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为**静态绑定**和**动态绑定**：

*   静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。

*   动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。

#### **加载**

    加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

    1、通过一个类的全限定名来获取其定义的二进制字节流。

    2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

    3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

    注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。

    相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

    加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

    说到加载，不得不提到类加载器，下面就具体讲述下类加载器。

    类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。

    站在Java虚拟机的角度来讲，只存在两种不同的类加载器：

*   启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。

*   所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

    站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：

* **启动类加载器**：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
*   **扩展类加载器**：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
*   **应用程序类加载器**：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

     应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：

 1）在执行非置信代码之前，自动验证数字签名。

 2）动态地创建符合用户特定需要的定制化构建类。

 3）从特定的场所取得java class，例如数据库中和网络中。

事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。

    这几种类加载器的层次关系如下图所示：

![](https://img-blog.csdn.net/20140105211242593)

    这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。

    双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

    使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。

####  **验证**

    验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。

*   文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 

*   元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。

*   字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。

*   符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

#### **准备**

    准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

    1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

    2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

   假设一个类变量的定义为：

public static int value = 3；

    那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

    下表列出了Java中所有基本数据类型以及reference类型的默认零值：

![](https://img-blog.csdn.net/20140105195119234) 

   这里还需要注意如下几点：

*   对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。

*   对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。

*   对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。

*   如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

    3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

   假设上面的类变量value被定义为： 

public static final int value = 3；

    编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆[**上一篇博文**](http://blog.csdn.net/ns_code/article/details/17845821)中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。

#### **解析**

   解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在[**Class类文件结构**](http://blog.csdn.net/ns_code/article/details/17675609)一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。

* **符号引用**（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

* **直接引用**（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。

    对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。

    解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。

 **1、类或接口的解析**：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。

 **2、字段解析**：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：

![](https://img-blog.csdn.net/20140105220608531)

#### **初始化**

    初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。

### **引申问题**

#### **加载阶段读入.class文件，class文件是二进制吗，为什么需要使用二进制的方式**？

Class文件是一组以8字节为基础单位的二进制流。因为要将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

#### **验证过程是防止什么问题？验证过程是怎样的？加载和验证的执行顺序？符号引用的含义**？

* 为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全

* 过程大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证

* 先加载后验证

* 这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是**对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验**

#### **准备过程的静态成员变量分配空间和设置初始值问题**。
在使用前必须显式地为其赋值，否则编译时不通过

#### **解析过程符号引用替代为直接引用细节相关**。

这里说明下符号引用和直接引用的区别与关联：

*   符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。

*   直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

#### **初始化过程jvm的显式初始化相关**。

在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。

#### **类卸载的过程及触发条件**。

JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：

* 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。
   
* 加载该类的ClassLoader已经被GC。

* 该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法

## 三种类加载器，如何自定义一个类加载器？

调用loadClass时会先根据委派模型在父加载器中加载，如果加载失败，则会调用当前加载器的findClass来完成加载。

1、如果不想打破双亲委派模型，那么只需要重写findClass方法即可

2、如果想打破双亲委派模型，那么就重写整个loadClass方法

当然，我们自定义的ClassLoader不想打破双亲委派模型，所以自定义的ClassLoader继承自java.lang.ClassLoader并且只重写findClass方法。

## 双亲委派机制。

这几种类加载器的层次关系如下图所示：

![](https://img-blog.csdn.net/20140105211242593)

    这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。

    双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

## JVM内存分配策略，优先放于eden区、动态对象年龄判断、分配担保策略等。

* **内存的分配**，主要是在堆里面进行分配（也有可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），堆里面主要是发生在新生代的Eden区中，少数情况下是在老年代中，分配的规则不是固定的，这需要根据当前使用的是哪种垃圾收集器组合还有虚拟机与内存相关的参数设置。

* 对象优先在Eden分配

大多数情况下，对象在新生代Eden区进行分配。当Eden区没有足够空间进行分配时JVM发生一次Minor GC。什么叫Minor GC呢？Minor GC是指发生在新生代的垃圾收集动作，因为Java对象大多具备朝生夕死的特性，所以Minor GC非常频繁，当然了，其回收速度肯定也是比较快的~，与之对应，还有个Full GC或者称为Major GC,是指老年代中的GC，经常会伴随一次Minor GC，Major GC速度一般会比Minor GC速度慢10倍以上！

* 大对象直接进入老年代

所谓的大对象，是指占用大量连续内存空间的Java对象。最经典的大对象就是那种很长的字符串和数组。大对象对于虚拟机来说是个坏消息~我们写程序时，尽量要避免出现一群朝生夕死的大对象。经常出现大对象容易导致内存还有不少空间时就得提前触发垃圾收集以获取足够的空间来存放大对象。

* 长期存活的对象将进入老年代

JVM采用分代收集思想来管理内存，就要去区分哪些是年轻的对象，哪些是老年的对象。我们知道，刚创建的对象肯定是年轻的对象，那么怎么将对象判断为老年呢？

在Eden区出生，并经过一次Minor GC后仍然存活，并且能被To Suvivor容纳，移动到To Suvivor区后，年龄设置为1。以后每经历一次Minor GC就将年龄加1，当它的年龄达到一个阀值（默认15，也可以更改-XX:MaxTenurinigThreshold来设置），就会被晋级到老年代中。

* 动态对象年龄判定

为了更好地适应不同程序内存情况，JVM并不一定是等到对象年龄达到阀值才将对象晋级到老年代。**如果在Survivor空间中的相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年的对象就可以直接进入老年代，无需等到指定的阀值**。这句话可能有点绕，不太好理解，我来再解释一下，就是说，假设Survivor的空间大小为max，年龄为y的对象总共有n个，如果y*n>max/2，那么所有年龄大于y的对象全部进入到老年代。

## JVM垃圾回收策略

### 怎样判对象、类需要被回收？

可达性分析法，对象引用链到GCRoot是否可达，不可达就可被回收。

### 四种垃圾回收算法标记-清除、复制、标记-整理、分代收集。

分代回收 年轻代，老年代，永久代。
年轻代使用的是复制算法
老年代和永久代使用的是标记清除或者标记整理法，根据不同的GC收集器来看


### JVM中的垃圾回收器，新生代回收器、老年代回收器、stop-the-world概念及解决方法。

[深入理解JVM(3)——7种垃圾收集器- 王泽远的博客| Crow's Blog](https://crowhawk.github.io/2017/08/15/jvm_3/)

*   **新生代GC（Minor GC）**：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。

*   **老年代GC（Major GC / Full GC）**：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

| 收集器 | 串行、并行or并发 | 新生代/老年代 | 算法 | 目标 | 适用场景 |
| --- | --- | --- | --- | --- | --- |
| **Serial** | 串行 | 新生代 | 复制算法 | 响应速度优先 | 单CPU环境下的Client模式 |
| **Serial Old** | 串行 | 老年代 | 标记-整理 | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备预案 |
| **ParNew** | 并行 | 新生代 | 复制算法 | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合 |
| **Parallel Scavenge** | 并行 | 新生代 | 复制算法 | 吞吐量优先 | 在后台运算而不需要太多交互的任务 |
| **Parallel Old** | 并行 | 老年代 | 标记-整理 | 吞吐量优先 | 在后台运算而不需要太多交互的任务 |
| **CMS** | 并发 | 老年代 | 标记-清除 | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
| **G1** | 并发 | both | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用，将来替换CMS |

**Serial**
**它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）**

## 四类引用及使用场景？

### 强引用

 强引用在程序内存不足（OOM）的时候也不会被回收。 直接new 出来的对象。

只要你给强引用对象 s 赋空值 null, 该对象就可以被垃圾回收器回收。因为该对象此时不再含有其他强引用

### 软引用  

软引用在程序内存不足时，会被回收。

**可用场景：** 
创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。

### 弱引用 

弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。

**可用场景：** 
防止内存泄漏，内部类对外部类的引用可以放在弱引用中

### 虚引用

虚引用的回收机制跟弱引用差不多，但是它被**回收之前**，会被放入`ReferenceQueue`中。

注意哦，其它引用是被JVM回收后才被传入`ReferenceQueue`中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有`ReferenceQueue`

**可用场景：** 
对象销毁前的一些操作，比如说资源释放等

基本上JVM方面所有的大的概念全部问到，真的需要理解到位。JVM比较熟悉，全程巴拉巴拉不停地说，有惊无险。

## 集合类
初始引起话题的问题：hashmap了解吗？心中一喜，开启侃侃而谈（胡吹）模式。讲到了以下的一些点：

### hashmap实现的数据结构

数组+链表。

### hashmap的哈希冲突解决方法：

拉链法等。拉链法的优缺点。

#### 解决方法

1.开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
2.再哈希法
3.链地址法(Java hashmap就是这么做的)
4.建立一个公共溢出区

#### 链地址法如何解决hash冲突

*   HashMap在处理冲突时使用链表存储相同索引的元素。

*   从Java 8开始，HashMap，ConcurrentHashMap和LinkedHashMap在处理频繁冲突时将使用平衡树来代替链表，当同一hash桶中的元素数量超过特定的值便会由链表切换到平衡树，这会将get()方法的性能从O(n)提高到O(logn)。

*   当从链表切换到平衡树时，HashMap迭代的顺序将会改变。不过这并不会造成什么问题，因为HashMap并没有对迭代的顺序提供任何保证。

*   从Java 1中就存在的Hashtable类为了保证迭代顺序不变，即便在频繁冲突的情况下也不会使用平衡树。这一决定是为了不破坏某些较老的需要依赖于Hashtable迭代顺序的Java应用。

*   除了Hashtable之外，WeakHashMap和IdentityHashMap也不会在频繁冲突的情况下使用平衡树。

*   使用HashMap之所以会产生冲突是因为使用了键对象的hashCode()方法，而equals()和hashCode()方法不保证不同对象的hashCode是不同的。需要记住的是，相同对象的hashCode一定是相同的，但相同的hashCode不一定是相同的对象。

*   在HashTable和HashMap中，冲突的产生是由于不同对象的hashCode()方法返回了一样的值。

在Java 8 之前， 如果发生碰撞往往是将该value直接链接到该位置的其他所有value的末尾，即相互碰撞的所有value形成一个链表。

因此，在最坏情况下，HashMap的查找时间复杂度将退化到O（n）。

但是在Java 8 中，该碰撞后的处理进行了改进。当一个位置所在的冲突过多时，存储的value将形成一个排序二叉树，排序依据为key的hashcode。

在最坏情况下，HashMap的查找时间复杂度将从O（1）退化到O（logn）。

虽然是一个小小的改进，但意义重大：

1、O（n）到O（logn）的时间开销。

2、**如果恶意程序知道我们用的是Hash算法，则在纯链表情况下，它能够发送大量请求导致哈希碰撞，然后不停访问这些key导致HashMap忙于进行线性查找，最终陷入瘫痪，即形成了拒绝服务攻击**（DoS）。

### hashmap的参数及影响性能的关键参数：加载因子和初始容量。

* 容量是HashMap在创建时“桶”的数量，而初始容量是哈希表在创建时分配的空间大小。

* 加载因子是哈希表在其容量自动增加时能达到多满的衡量尺度（比如默认为0.75，即桶中数据达到3/4就不能再放数据了）。

* 如果加载因子过大，迭代性能会下降，虽然空间开销减少。如果初始容量小于最大条目数除以加载因子，则会发生 rehash 操作。

* rehash操作即重建内部数据结构，一般是增加桶数为原来的两倍。

如果有很多K-V对要添加到HashMap中，则最好分配大点的初始容量，以减少rehash操作

### Resize操作的过程。

**扩容问题。**

* 随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。

* 该临界点在当HashMap中元素的数量等于table数组长度x加载因子（比如默认为0.75，即桶中数据达到3/4就不能再放数据了）。

* 但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。

* 所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。

### hashmap容量为2次幂的原因。

进行一个%运算，但是%运算效率太过低下，计算机里面位运算是基本运算，位运算的效率是远远高于取余%运算的，同时为了保证2进制的情况下进行一个均匀分布，所以把容量设置成2的幂

### hashtable线程安全、synchronized加锁。

### hashtable和hashmap异同。

*   1.HashTable的方法是同步 的，在方法的前面都有synchronized来同步，HashMap未经同步，所以在多线程场合要手动同步 HashMap这个区别就像Vector和ArrayList一样。可以通过 Map m = Collections.synchronizedMap(new HashMap(...)); 对HashMap进行同步操作。

*   2.HashTable不允许null值(key和value都不可以) ,HashMap允许null值(key和value都可以)。

*   3.HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。

*   4.HashTable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。以上只是表面的不同，它们的实现也有很大的不同。

*   5.HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。

*   6.哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值，而且用与代替求模。

### 为什么hashtable被弃用？
效率低

### ConcurrentHashMap

#### ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。通过lock()和unlock().

讲了concurrenthashmap相比于hashtable做的优化、segment的概念、concurrenthashmap高效的原因。中间面试官问的问题：

#### Segment 类

Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶

#### 容器类中fast-fail机制。

* 当多个线程对同一个集合的内容进行操作时，**就可能**会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。

* 单线程在用迭代器取值的时候，如果中途改变了集合的情况，迭代过程就会报ConcurrentModificationException异常

**产生原因**

若 “**modCount 不等于 expectedModCount**”，则抛出ConcurrentModificationException异常，产生fail-fast事件。

要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！
从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改。所以，需要考证的就是modCount何时会被修改

1，在单线程操作不符合规则的时候，list加入元素，迭代器不知道,modCount发生变化，与期望不等

2，多线程操作的时候，线程1在获取到当前modCount的时候，线程2进行了一些涉及元素个数变化的操作使得modCount发生了变化，与期望的count不等

然后会抛出ConcurrentModificationException异常，产生fail-fast机制

**避免ConcurrentModificationException异常的方法**：

* 通过util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件

* 使用CopyOnWriteArrayList来替换ArrayList


#### concurrenthashmap的插入操作是直接操作数组中的链表吗？

**是的，判断是否扩容，然后定位，再操作**

在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。

* 是否需要扩容。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。

* 值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。

* 如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。

## 多线程

由于上面提出了concurrenthashmap的概念，顺理成章聊起了多线程。有了上一部分的经验全程我主动讲，面试官针对性问了一些问题，大概内容如下：

## 为什么要使用多线程？多线程需要注意的问题。上下文开销、死锁等。

*   **充分利用CPU资源**
*   **提高计算机的执行效率**

* 线程安全问题，上下文开销、死锁等

## java内存模型、导致线程不安全的原因。

volatile关键字，缓存一致性、指令重排序概念。

synchronize关键字，java对象、Markword概念、

synchronize底层monitorenter和moniterexit指令。

lock语句和synchronize对比。

原子操作，CAS概念、相关参数。

乐观锁、悲观锁概念及使用场景。

线程池概念、实现原理等。


JVM锁的优化，偏向锁、轻量级锁概念及原理。

多线程方面回答得比较好，面试官反馈比较满意。

## 数据库
数据库方面笔者水平较菜，没有深入了解。面试官问了一个问题，

### SQL语句中对表或者字段取别名有什么好处？

**字段名与数据库中的关键字冲突**的时候。

#### 为表取别名
* 查询数据时，如果表名很长，使用起来不方便，此时，就可以为表取一个别名，用这个别名来代替表的名称 
SELECT * FROM 表名 [AS] 别名； 
注意，为表指定别名，AS关键字可以省略不写

#### 为字段取别名
* 查询数据时，为了使显示的查询结果更加直观，可以为字段取一个别名 
SELECT 字段名 [AS] 别名 [，字段名 [AS] 别名，……] FROM 表名； 
注意，为字段指定别名，AS关键字可以省略不写

## 通信协议
接下来是对通信协议的了解，大概问了下列问题：

### TCP三次握手、四次挥手。

#### 三次握手
1.  第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；**客户端给服务器发包。 此时服务器确认自己可以接收客户端的包，客户端不确认服务器是否接收到了自己发的包**。 

2.  第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；**服务器端回复客户端。 此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包**。
 
3.  第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。**客户端回复服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的包。两边都没有问题，开始通信**

完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。

#### 那四次分手呢？

当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。

；当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

1.  第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

**当主机1发出`FIN`报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了，但是，这个时候主机1还是可以接受来自主机2的数据**

2.  第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；

**当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的**

3.  第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；

**当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了**

4.  第四次分手：**主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了**。

### http请求报文结构、响应报文，状态码。
##### HTTP报文

*   请求报文
    *   报文头部
        *   请求行：包括请求方法类型：GET、POST等，请求地址，协议版本
        *   请求头部字段
        *   通用头部字段
        *   实体头部字段
        *   其他
    *   报文主体：包括如POST中的请求参数、文件上传数据、邮件传输数据等内容
*   响应报文
    *   报文头部
        *   状态行
        *   响应头部字段
        *   通用头部字段
        *   实体头部字段
        *   其他
    *   报文主体：包括网页正文等内容

##### 根据上述内容，HTTP头部字段包括：

*   请求头部字段：补充请求的附加内容、客户端信息、响应内容相关优先级等。有Accept、From、Host等字段
*   响应头部字段：补充响应的附加内容
*   通用头部字段：请求报文、响应报文都会使用，包括Cache-Control字段，作用是控制HTTP缓存机制
*   实体头部字段：补充资源内容的更新时间等

#### HTTP状态码

| 状态码 | 含义 |
| --- | --- |
| 1xx | 信息性状态码 |
| 2xx | 成功状态码 |
| 3xx | 重定向状态码 |
| 4xx | 客户端错误状态码 |
| 5xx | 服务器错误状态码 |


### http2.0相比于http1.0的新特性，推送、多路复用、消息头压缩等。

**服务器推送到底是什么？**
服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

**为什么需要头部压缩**？假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍

**HTTP2.0多路复用有多好**？
**多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息**
HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

通信协议问得不是太深，了解得比较好即可。面试官反馈比较好。最后就是问android了，面试官说感觉你android应该挺厉害的，当时真的是受宠若惊。

## android
android是重头戏。由于之前已经了解挺多，android方面基础的没有多问，比较深入。大概有如下问题：

### handler机制组成
handler机制每一部分的源码包括looper中的loop方法、    threadlocal概念、dispatchmessage方法源码，runnable封装message等。

### listview缓存机制、recycleview缓存机制。

[Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21#wechat_redirect)

### bitmap高效加载，三级缓存等。

#### bitmap高效加载

解决这个问题的核心思路是根据图片需要显示的大小来缩放图片进行显示，缩放的方式为设置采样率。

##### 获取采样率的方法和步骤：

1.  将 BitmapFactory.Options 的 **inJustDecodeBounds** 参数设置为 true；
2.  从 BitmapFactory.Options 中取出图片的原始宽高信息，也就是 **outWidth 和 outHeight** 参数；
3.  结合目标 View 所需大小来计算所需采样率 inSampleSize；
4.  将 BitmapFactory.Options 的 **inJustDecodeBounds** 设置为 false，重新加载图片。

**设置inJustDecodeBounds 参数为 true 时只会解析图片的宽/高信息，并不会去加载图片，所以该操作是轻量级的**。

##### 压缩到指定宽高，质量压缩

#### 三级缓存

内存缓存、本地缓存（磁盘缓存）、网络缓存。

*   LruCache：内存缓存
*   DiskLruCache：磁盘缓存

### binder机制原理。

### view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？

draw可以放在子线程中去执行，postInvalidate方法就是在子线程中执行的。

### draw方法中需要注意的问题？

不能new对象，导致内存不足，频繁GC导致内存抖动，页面卡顿。

### view的事件分发机制。

### android性能优化

布局优化、绘制优化、内存泄露优化、bitmap、内存泄露等。

内存泄露的概念？android中发生的场景？怎么解决？讲了handler、动画等。

面试android方面的时候已经真正地淡定下来了，有条不紊地和面试官说了自己所有的理解。反馈也挺好。

### 算法
最后是一题在线编程，题目比较常规，是一题最大连续子序列，需要注意全是负数的处理，在此不赘述可自行百度。
```
/**
 * 最大子序和 * * @param nums
  */
 public static int maxSubArray(int[] nums) {
        if (null == nums || nums.length == 0) {
            return 0;
        }

        int sum = 0;
        int maxValue = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (sum > maxValue) {
                maxValue = sum;
            }
            if (sum < 0) {
                sum = 0;
            }
        }
        return maxValue;
    }
```

# 三面

三面面试官感觉是部门主管级别，上来自我介绍后开始问问题。问了一下简历上在学校做的一个android的项目，说一个难点，讲了推送，巴拉巴拉讲了一通极光推送，感觉面试官不是很感冒，问了极光推送的实现原理，笔者一紧张竟然忘了讲长连接……又问了华为实习的项目，难点，怎么优化……我扯了一通字母树，感觉面试官还是不太感冒。这个时候已经有点慌张，然后……面试官开始问优缺点、之前签的公司、为什么想去杭州、你是怎么看待算法？还问了最优成就感的一件事情，你觉得为什么会获得一等奖？是不是因为对手太弱了（懵了……）？回答完直接问还有什么问题想问他…

# 四面 交叉面

通信协议

## TCP保证可靠传输的实现：停止等待协议、滑动窗口协议、流量控制、拥塞控制等。

项目

说一个你记忆比较深刻的功能：我讲了一个查看当前WiFi网络连接终端信息的功能的实现。

说一下你遇到的问题：讲了一个十几万级别的字符串的匹配通过字母树优化的问题。面试官听了后和我详细分析了一下，得到了一个更好的实现方法……当时一阵汗颜，班门弄斧了。

## 问了一下项目中使用到的三级缓存策略。

获奖

聊了聊获奖经历，中间是怎么学习的。面试官看了看前面的面试过程，说问了多线程了，那他就不问了……

## 数据库
数据库方面问了以下的问题：

### 索引的种类。
**普通索引**
**唯一索引**
**主键索引**
**组合索引**

### B树、B+树、红黑树。

### B+树和B树相比有什么优点，应用场景？

### 红黑树的一些特点？怎样保持平衡？

问着数据库，问着问着扯到数据结构那边去了……说完之后面试官是感觉你这些都有所准备啊，我说对，毕竟是面阿里，面试官笑了说我本来还准备问你一下八大排序的现在感觉你应该都会，我很自信（jian zha）地说对，我都会。至此，面试官说技术方面他没什么问题想问的了，他这是一轮交叉面，集团内部要求的，他是后台开发方面的，不懂android，问我还有什么想问的。笔者抛出了万金油问题，您觉得我还有哪些方面需要优化的。面试官哈哈一笑，说你们这些学生现在问的都是套路问题，他基本上回答的都是这个问题，然后说了一通感觉深度和广度都有，继续保持就好了。四面48min。至此，笔者彻底放心。互道周末愉快后结束了面试。和女友分享喜报后，阿里之路的进度条已经走到80%了。至于为什么有交叉面，众说纷纭，不太清楚。

# 五面(HR)
度过周末后照例去图书馆学习，在周一下午接到hr的电话。周末准备了一些常见的HR面试问题，结果一个都没问到，问到的问题大概如下：

关于之前一次笔试的编程题，为什么没有做出来？后来有思考过吗？
你签约的公司给的薪水是怎么样的？如果阿里给你offer，你是怎么考量这两个offer的？
为什么没有在之前实习的公司留下来？之前公司的主管是怎么评价你的？
你的优缺点？
最后日常问问题，万金油问题培养体系和晋升机制。面完告知一到两周会有结果，要从池子里综合考量捞出一批人给offer（心中一慌，毕竟走到最后的对手都不容小觑）。随后HR面试官加了微信，有问题可以在微信上交流。

# 布局优化，约束布局，看帧的绘制


# 内存不足回收软引用机制

# Synchronized和RantrantLock的使用场景，读写锁
公平和不公平锁
Synchronized无线等待，RantrantLoak可以设置等待时间，可以被中断

Synchronized 同步，
Volatile 同步，
重入锁ReentrantLock同步，
ThreadLocal局部变量同步，
LinkedBlockingQueue<E>来阻塞队列同步

b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 

c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁

# message obtain获取和new 出来有啥区别

创建message的方法：

```
 //创建message
            //1、new的方式
            Message message1 = new Message();
            message1.what = 1;

            //2、Message.obtain的方式
            Message message2 = Message.obtain();
            message2.what = 1;

            //3、Handler.obtainMessage的方式
//从整个Messge池中返回一个新的Message实例,避免创建对象，从而减少内存的开销了。
            Message message3 = new Handler().obtainMessage();

//从整个Messge池中返回一个新的Message实例,避免创建对象，从而减少内存的开销了。
            Message message4 = new Handler().obtainMessage(1);
            //what=1,同message1，message2相同
```
**结论：获取Message对象的最好方法是调用Message.obtain()或者Handler.obtainMessage(), 这样是从一个可回收对象池中获取Message对象**。

从整个Messge池中返回一个新的Message实例，在许多情况下使用它，因为它能避免分配新的对象

如果是这样的话，那么通过调用obtainMessage方法获取Message对象就能避免创建对象，从而减少内存的开销了。

