垃圾回收
===


垃圾回收，结合具体案例分析（比如onDraw中为什么不能频繁new对象）
[android--垃圾回收与内存优化](https://www.jianshu.com/p/5f5e2a608871)

执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。

通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。

### 年轻代（young generation）

年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做**Minor GC**。年轻代被分为3个部分**——Enden区**和两个**Survivor区**。

*   大多数新建的对象都位于Eden区。
*   当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。
*   Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。
*   经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。

### 老年代（Old Generation）

年老代内存里包含了长期存活的对象和经过多次**Minor GC**后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做**Major GC**。Major GC会花费更多的时间。

### 永久代（Permanent Generation）

存放方法区，方法区中有要加载的类信息、静态变量、final类型的常量、属性和方法信息。

### **导致GC频繁执行有两个原因：**
* 1.内存抖动
* 2.瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。

所以避免在onDraw方法中创建对象。
